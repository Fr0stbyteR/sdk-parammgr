{
  "version": 3,
  "sources": ["../src/AudioWorkletRegister.js", "../src/CompositeAudioNode.js", "../src/ParamMgrProcessor.js", "../node_modules/@webaudiomodules/sdk/src/WamEnv.js", "../node_modules/@webaudiomodules/sdk/node_modules/@webaudiomodules/api/src/AbstractWebAudioModule.js", "../node_modules/@webaudiomodules/sdk/src/WebAudioModule.js", "../node_modules/@webaudiomodules/sdk/src/WamParameterInfo.js", "../node_modules/@webaudiomodules/sdk/src/RingBuffer.js", "../node_modules/@webaudiomodules/sdk/src/WamEventRingBuffer.js", "../node_modules/@webaudiomodules/sdk/src/WamNode.js", "../src/ParamConfigurator.js", "../src/MgrAudioParam.js", "../src/ParamMgrNode.js", "../src/ParamMgrFactory.js"],
  "sourcesContent": ["/** @type {Window & { AudioWorkletRegister?: typeof AudioWorkletRegister }} */\n// @ts-ignore\nconst window = globalThis;\n\nexport const registeredProcessors = window.AudioWorkletRegister?.registeredProcessors || new WeakMap();\nexport const registeringProcessors = window.AudioWorkletRegister?.registeringProcessors || new WeakMap();\nexport const resolves = window.AudioWorkletRegister?.resolves || {};\nexport const rejects = window.AudioWorkletRegister?.rejects || {};\n\nexport default class AudioWorkletRegister {\n\tstatic registeredProcessors = registeredProcessors;\n\n\tstatic registeringProcessors = registeringProcessors;\n\n\tstatic resolves = resolves;\n\n\tstatic rejects = rejects;\n\n\tstatic async registerProcessor(processorId, processor, audioWorklet, ...injection) {\n\t\tthis.registeringProcessors.get(audioWorklet).add(processorId);\n\t\ttry {\n\t\t\tconst url = URL.createObjectURL(new Blob([`(${processor.toString()})(${[processorId, ...injection].map(s => JSON.stringify(s)).join(', ')});`], { type: 'text/javascript' }));\n\t\t\tawait audioWorklet.addModule(url);\n\t\t\tthis.resolves[processorId].forEach((f) => f());\n\t\t\tthis.registeringProcessors.get(audioWorklet).delete(processorId);\n\t\t\tthis.registeredProcessors.get(audioWorklet).add(processorId);\n\t\t} catch (e) {\n\t\t\tthis.rejects[processorId].forEach((f) => f(e));\n\t\t}\n\t\tthis.rejects[processorId] = [];\n\t\tthis.resolves[processorId] = [];\n\t}\n\n\tstatic async register(processorId, processor, audioWorklet, ...injection) {\n\t\tif (!this.resolves[processorId]) this.resolves[processorId] = [];\n\t\tif (!this.rejects[processorId]) this.rejects[processorId] = [];\n\t\tconst promise = new Promise((resolve, reject) => {\n\t\t\tthis.resolves[processorId].push(resolve);\n\t\t\tthis.rejects[processorId].push(reject);\n\t\t});\n\t\tif (!this.registeringProcessors.has(audioWorklet)) {\n\t\t\tthis.registeringProcessors.set(audioWorklet, new Set());\n\t\t}\n\t\tif (!this.registeredProcessors.has(audioWorklet)) {\n\t\t\tthis.registeredProcessors.set(audioWorklet, new Set());\n\t\t}\n\t\tconst registered = this.registeredProcessors.get(audioWorklet).has(processorId);\n\t\tconst registering = this.registeringProcessors.get(audioWorklet).has(processorId);\n\t\tif (registered) return Promise.resolve();\n\t\tif (registering) return promise;\n\t\tif (!registered && audioWorklet) {\n\t\t\tthis.registerProcessor(processorId, processor, audioWorklet, ...injection);\n\t\t}\n\t\treturn promise;\n\t}\n}\n\nif (!window.AudioWorkletRegister) window.AudioWorkletRegister = AudioWorkletRegister;\n", "/** @typedef {import('@webaudiomodules/api').WamNode} WamNode */\n/** @typedef {import('@webaudiomodules/api').WebAudioModule} WebAudioModule */\n\n/**\n * @implements {WamNode}\n */\nexport default class CompositeAudioNode extends GainNode {\n\tget processorId() {\n\t\treturn this._wamNode.processorId;\n\t}\n\n\tget instanceId() {\n\t\treturn this._wamNode.instanceId;\n\t}\n\n\tget module() {\n\t\treturn this._wamNode.module;\n\t}\n\n\t/**\n\t * @param {Parameters<WamNode['getParameterInfo']>} args\n\t */\n\tgetParameterInfo(...args) {\n\t\treturn this._wamNode.getParameterInfo(...args);\n\t}\n\n\t/**\n\t * @param {Parameters<WamNode['getParameterValues']>} args\n\t */\n\tgetParameterValues(...args) {\n\t\treturn this._wamNode.getParameterValues(...args);\n\t}\n\n\t/**\n\t * @param {Parameters<WamNode['setParameterValues']>} args\n\t */\n\tsetParameterValues(...args) {\n\t\treturn this._wamNode.setParameterValues(...args);\n\t}\n\n\tgetState() {\n\t\treturn this._wamNode.getState();\n\t}\n\n\t/**\n\t * @param {Parameters<WamNode['setState']>} args\n\t */\n\tsetState(...args) {\n\t\treturn this._wamNode.setState(...args);\n\t}\n\n\tgetCompensationDelay() {\n\t\treturn this._wamNode.getCompensationDelay();\n\t}\n\n\t/**\n\t * @param {Parameters<WamNode['scheduleEvents']>} args\n\t */\n\tscheduleEvents(...args) {\n\t\treturn this._wamNode.scheduleEvents(...args);\n\t}\n\n\tclearEvents() {\n\t\treturn this._wamNode.clearEvents();\n\t}\n\n\t/**\n\t * @param {Parameters<WamNode['connectEvents']>} args\n\t */\n\tconnectEvents(...args) {\n\t\treturn this._wamNode.connectEvents(...args);\n\t}\n\n\t/**\n\t * @param {Parameters<WamNode['disconnectEvents']>} args\n\t */\n\tdisconnectEvents(...args) {\n\t\treturn this._wamNode.disconnectEvents(...args);\n\t}\n\n\tdestroy() {\n\t\treturn this._wamNode.destroy();\n\t}\n\n\t/**\n\t * @type {AudioNode}\n\t */\n\t_output = undefined;\n\n\t/**\n\t * @type {WamNode}\n\t */\n\t_wamNode = undefined;\n\n\tset channelCount(count) {\n\t\tif (this._output) this._output.channelCount = count;\n\t\telse super.channelCount = count;\n\t}\n\n\tget channelCount() {\n\t\tif (this._output) return this._output.channelCount;\n\t\treturn super.channelCount;\n\t}\n\n\tset channelCountMode(mode) {\n\t\tif (this._output) this._output.channelCountMode = mode;\n\t\telse super.channelCountMode = mode;\n\t}\n\n\tget channelCountMode() {\n\t\tif (this._output) return this._output.channelCountMode;\n\t\treturn super.channelCountMode;\n\t}\n\n\tset channelInterpretation(interpretation) {\n\t\tif (this._output) this._output.channelInterpretation = interpretation;\n\t\telse super.channelInterpretation = interpretation;\n\t}\n\n\tget channelInterpretation() {\n\t\tif (this._output) return this._output.channelInterpretation;\n\t\treturn super.channelInterpretation;\n\t}\n\n\tget numberOfInputs() {\n\t\treturn super.numberOfInputs;\n\t}\n\n\tget numberOfOutputs() {\n\t\tif (this._output) return this._output.numberOfOutputs;\n\t\treturn super.numberOfOutputs;\n\t}\n\n\tget gain() {\n\t\treturn undefined;\n\t}\n\n\tconnect(...args) {\n\t\t// @ts-ignore\n\t\tif (this._output && this._output !== this) return this._output.connect(...args);\n\t\t// @ts-ignore\n\t\treturn super.connect(...args);\n\t}\n\n\tdisconnect(...args) {\n\t\t// @ts-ignore\n\t\tif (this._output && this._output !== this) return this._output.disconnect(...args);\n\t\t// @ts-ignore\n\t\treturn super.disconnect(...args);\n\t}\n}\n", "/** @typedef {import('@webaudiomodules/api').WamProcessor} WamProcessor */\n/** @typedef {import('@webaudiomodules/api').WamParameterInfoMap} WamParameterInfoMap */\n/** @typedef {import('@webaudiomodules/api').WamParameterDataMap} WamParameterValueMap */\n/** @typedef {import('@webaudiomodules/api').WamEvent} WamEvent */\n/** @typedef {import('./types').ParamMgrOptions} ParamMgrProcessorOptions */\n/** @typedef {import('./TypedAudioWorklet').AudioWorkletGlobalScope} AudioWorkletGlobalScope */\n/** @typedef {import('./TypedAudioWorklet').TypedAudioWorkletProcessor} AudioWorkletProcessor */\n/** @template M @typedef {import('./types').MessagePortRequest<M>} MessagePortRequest */\n/** @template M @typedef {import('./types').MessagePortResponse<M>} MessagePortResponse */\n/** @typedef {import('./types').ParamMgrCallFromProcessor} ParamMgrCallFromProcessor */\n/** @typedef {import('./types').ParamMgrCallToProcessor} ParamMgrCallToProcessor */\n/** @typedef {import('./types').ParamMgrAudioWorkletOptions} ParamMgrAudioWorkletOptions */\n/** @typedef {import('./types').ParametersMapping} ParametersMapping */\n\n/**\n * Main function to stringify as a worklet.\n *\n * @param {string} processorId processor identifier\n * @param {WamParameterInfoMap} paramsConfig parameterDescriptors\n */\nconst processor = (processorId, paramsConfig) => {\n\t/** @type {AudioWorkletGlobalScope} */\n\t// @ts-ignore\n\tconst audioWorkletGlobalScope = globalThis;\n\tconst { AudioWorkletProcessor, registerProcessor } = audioWorkletGlobalScope;\n\tconst supportSharedArrayBuffer = !!globalThis.SharedArrayBuffer;\n\tconst SharedArrayBuffer = globalThis.SharedArrayBuffer || globalThis.ArrayBuffer;\n\tconst normExp = (x, e) => (e === 0 ? x : x ** (1.5 ** -e));\n\tconst normalizeE = (x, min, max, e = 0) => (\n\t\tmin === 0 && max === 1\n\t\t\t? normExp(x, e)\n\t\t\t: normExp((x - min) / (max - min) || 0, e));\n\tconst normalize = (x, min, max) => (min === 0 && max === 1 ? x : (x - min) / (max - min) || 0);\n\tconst denormalize = (x, min, max) => (min === 0 && max === 1 ? x : x * (max - min) + min);\n\tconst mapValue = (x, eMin, eMax, sMin, sMax, tMin, tMax) => (\n\t\tdenormalize(\n\t\t\tnormalize(\n\t\t\t\tnormalize(\n\t\t\t\t\tMath.min(sMax, Math.max(sMin, x)),\n\t\t\t\t\teMin,\n\t\t\t\t\teMax,\n\t\t\t\t),\n\t\t\t\tnormalize(sMin, eMin, eMax),\n\t\t\t\tnormalize(sMax, eMin, eMax),\n\t\t\t),\n\t\t\ttMin,\n\t\t\ttMax,\n\t\t)\n\t);\n\n\t/**\n\t * @typedef {MessagePortRequest<ParamMgrCallToProcessor> & MessagePortResponse<ParamMgrCallFromProcessor>} MsgIn\n\t * @typedef {MessagePortResponse<ParamMgrCallToProcessor> & MessagePortRequest<ParamMgrCallFromProcessor>} MsgOut\n\t */\n\t/**\n\t * `ParamMgrNode`'s `AudioWorkletProcessor`\n\t *\n\t * @extends {AudioWorkletProcessor<MsgIn, MsgOut>}\n\t * @implements {WamProcessor}\n\t * @implements {ParamMgrCallToProcessor}\n\t */\n\tclass ParamMgrProcessor extends AudioWorkletProcessor {\n\t\tstatic get parameterDescriptors() {\n\t\t\treturn Object.entries(paramsConfig).map(([name, { defaultValue, minValue, maxValue }]) => ({\n\t\t\t\tname,\n\t\t\t\tdefaultValue,\n\t\t\t\tminValue,\n\t\t\t\tmaxValue,\n\t\t\t}));\n\t\t}\n\n\t\t/**\n\t\t * @param {ParamMgrProcessorOptions} options\n\t\t */\n\t\tconstructor(options) {\n\t\t\tsuper(options);\n\t\t\tthis.destroyed = false;\n\t\t\tthis.supportSharedArrayBuffer = supportSharedArrayBuffer;\n\t\t\tconst {\n\t\t\t\tparamsMapping,\n\t\t\t\tinternalParamsMinValues,\n\t\t\t\tinternalParams,\n\t\t\t\tinstanceId,\n\t\t\t} = options.processorOptions;\n\t\t\tthis.moduleId = processorId;\n\t\t\tthis.instanceId = instanceId;\n\t\t\tthis.internalParamsMinValues = internalParamsMinValues;\n\t\t\tthis.paramsConfig = paramsConfig;\n\t\t\tthis.paramsMapping = paramsMapping;\n\t\t\t/** @type {Record<string, number>} */\n\t\t\tthis.paramsValues = {};\n\t\t\tObject.entries(paramsConfig).forEach(([name, { defaultValue }]) => {\n\t\t\t\tthis.paramsValues[name] = defaultValue;\n\t\t\t});\n\t\t\tthis.internalParams = internalParams;\n\t\t\tthis.internalParamsCount = this.internalParams.length;\n\t\t\tthis.buffer = new SharedArrayBuffer((this.internalParamsCount + 1) * Float32Array.BYTES_PER_ELEMENT);\n\t\t\tthis.$lock = new Int32Array(this.buffer, 0, 1);\n\t\t\tthis.$internalParamsBuffer = new Float32Array(this.buffer, 4, this.internalParamsCount);\n\t\t\t/** @type {WamEvent[]} */\n\t\t\tthis.eventQueue = [];\n\n\t\t\t/** @type {(event: WamEvent) => any} */\n\t\t\tthis.handleEvent = null;\n\n\t\t\taudioWorkletGlobalScope.webAudioModules.create(this);\n\n\t\t\tthis.messagePortRequestId = -1;\n\t\t\t/** @type {Record<number, ((...args: any[]) => any)>} */\n\t\t\tconst resolves = {};\n\t\t\t/** @type {Record<number, ((...args: any[]) => any)>} */\n\t\t\tconst rejects = {};\n\t\t\t/**\n\t\t\t * @param {keyof ParamMgrCallFromProcessor} call\n\t\t\t * @param {any} args\n\t\t\t */\n\t\t\tthis.call = (call, ...args) => new Promise((resolve, reject) => {\n\t\t\t\tconst id = this.messagePortRequestId--;\n\t\t\t\tresolves[id] = resolve;\n\t\t\t\trejects[id] = reject;\n\t\t\t\tthis.port.postMessage({ id, call, args });\n\t\t\t});\n\t\t\tthis.handleMessage = ({ data }) => {\n\t\t\t\tconst { id, call, args, value, error } = data;\n\t\t\t\tif (call) {\n\t\t\t\t\t/** @type {any} */\n\t\t\t\t\tconst r = { id };\n\t\t\t\t\ttry {\n\t\t\t\t\t\tr.value = this[call](...args);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tr.error = e;\n\t\t\t\t\t}\n\t\t\t\t\tthis.port.postMessage(r);\n\t\t\t\t} else {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tif (rejects[id]) rejects[id](error);\n\t\t\t\t\t\tdelete rejects[id];\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (resolves[id]) {\n\t\t\t\t\t\tresolves[id](value);\n\t\t\t\t\t\tdelete resolves[id];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.port.start();\n\t\t\tthis.port.addEventListener('message', this.handleMessage);\n\t\t}\n\n\t\t/**\n\t\t * @param {ParametersMapping} mapping\n\t\t */\n\t\tsetParamsMapping(mapping) {\n\t\t\tthis.paramsMapping = mapping;\n\t\t}\n\n\t\tgetBuffer() {\n\t\t\treturn { lock: this.$lock, paramsBuffer: this.$internalParamsBuffer };\n\t\t}\n\n\t\tgetCompensationDelay() {\n\t\t\treturn 128;\n\t\t}\n\n\t\t/**\n\t\t * @param {string[]} parameterIdQuery\n\t\t */\n\t\tgetParameterInfo(...parameterIdQuery) {\n\t\t\tif (parameterIdQuery.length === 0) parameterIdQuery = Object.keys(this.paramsConfig);\n\t\t\t/** @type {WamParameterInfoMap} */\n\t\t\tconst parameterInfo = {};\n\t\t\tparameterIdQuery.forEach((parameterId) => {\n\t\t\t\tparameterInfo[parameterId] = this.paramsConfig[parameterId];\n\t\t\t});\n\t\t\treturn parameterInfo;\n\t\t}\n\n\t\t/**\n\t\t * @param {boolean} [normalized]\n\t\t * @param {string[]} parameterIdQuery\n\t\t */\n\t\tgetParameterValues(normalized, ...parameterIdQuery) {\n\t\t\tif (parameterIdQuery.length === 0) parameterIdQuery = Object.keys(this.paramsConfig);\n\t\t\t/** @type {WamParameterValueMap} */\n\t\t\tconst parameterValues = {};\n\t\t\tparameterIdQuery.forEach((parameterId) => {\n\t\t\t\tif (!(parameterId in this.paramsValues)) return;\n\t\t\t\tconst { minValue, maxValue, exponent } = this.paramsConfig[parameterId];\n\t\t\t\tconst value = this.paramsValues[parameterId];\n\t\t\t\tparameterValues[parameterId] = {\n\t\t\t\t\tid: parameterId,\n\t\t\t\t\tvalue: normalized ? normalizeE(value, minValue, maxValue, exponent) : value,\n\t\t\t\t\tnormalized,\n\t\t\t\t};\n\t\t\t});\n\t\t\treturn parameterValues;\n\t\t}\n\n\t\t/**\n\t\t * @param {WamEvent[]} events\n\t\t */\n\t\tscheduleEvents(...events) {\n\t\t\tthis.eventQueue.push(...events);\n\t\t\tconst { currentTime } = audioWorkletGlobalScope;\n\t\t\tthis.eventQueue.sort((a, b) => (a.time || currentTime) - (b.time || currentTime));\n\t\t}\n\n\t\tget downstream() {\n\t\t\tconst wams = new Set();\n\t\t\tconst { eventGraph } = audioWorkletGlobalScope.webAudioModules;\n\t\t\tif (!eventGraph.has(this)) return wams;\n\t\t\tconst outputMap = eventGraph.get(this);\n\t\t\toutputMap.forEach((set) => {\n\t\t\t\tif (set) set.forEach((wam) => wams.add(wam));\n\t\t\t});\n\t\t\treturn wams;\n\t\t}\n\n\t\t/**\n\t\t * @param {WamEvent[]} events\n\t\t */\n\t\temitEvents(...events) {\n\t\t\tconst { eventGraph } = audioWorkletGlobalScope.webAudioModules;\n\t\t\tif (!eventGraph.has(this)) return;\n\t\t\tconst downstream = eventGraph.get(this);\n\t\t\tdownstream.forEach((set) => {\n\t\t\t\tif (set) set.forEach((wam) => wam.scheduleEvents(...events));\n\t\t\t});\n\t\t}\n\n\t\tclearEvents() {\n\t\t\tthis.eventQueue = [];\n\t\t}\n\n\t\tlock() {\n\t\t\tif (globalThis.Atomics) Atomics.store(this.$lock, 0, 1);\n\t\t}\n\n\t\tunlock() {\n\t\t\tif (globalThis.Atomics) Atomics.store(this.$lock, 0, 0);\n\t\t}\n\n\t\t/**\n\t\t * Main process\n\t\t *\n\t\t * @param {Float32Array[][]} inputs\n\t\t * @param {Float32Array[][]} outputs\n\t\t * @param {Record<string, Float32Array>} parameters\n\t\t */\n\t\tprocess(inputs, outputs, parameters) {\n\t\t\tif (this.destroyed) return false;\n\t\t\tconst outputOffset = 1;\n\t\t\tthis.lock();\n\t\t\tObject.entries(this.paramsConfig).forEach(([name, { minValue, maxValue }]) => {\n\t\t\t\tconst raw = parameters[name];\n\t\t\t\tif (name in this.paramsValues) this.paramsValues[name] = raw[raw.length - 1]; // Store to local temporary\n\t\t\t\tif (!this.paramsMapping[name]) return; // No need to output\n\t\t\t\tObject.entries(this.paramsMapping[name]).forEach(([targetName, targetMapping]) => {\n\t\t\t\t\tconst j = this.internalParams.indexOf(targetName);\n\t\t\t\t\tif (j === -1) return;\n\t\t\t\t\tconst intrinsicValue = this.internalParamsMinValues[j]; // Output will be added to target intrinsicValue\n\t\t\t\t\tconst { sourceRange, targetRange } = targetMapping;\n\t\t\t\t\tconst [sMin, sMax] = sourceRange;\n\t\t\t\t\tconst [tMin, tMax] = targetRange;\n\t\t\t\t\tlet out;\n\t\t\t\t\tif (minValue !== tMin || maxValue !== tMax\n\t\t\t\t\t\t\t|| minValue !== sMin || maxValue !== sMax) { // need to calculate with mapping\n\t\t\t\t\t\tout = raw.map((v) => {\n\t\t\t\t\t\t\tconst mappedValue = mapValue(v, minValue, maxValue, sMin, sMax, tMin, tMax);\n\t\t\t\t\t\t\treturn mappedValue - intrinsicValue;\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (intrinsicValue) { // need to correct with intrinsicValue\n\t\t\t\t\t\tout = raw.map((v) => v - intrinsicValue);\n\t\t\t\t\t} else { // No need to modify\n\t\t\t\t\t\tout = raw;\n\t\t\t\t\t}\n\t\t\t\t\tif (out.length === 1) outputs[j + outputOffset][0].fill(out[0]);\n\t\t\t\t\telse outputs[j + outputOffset][0].set(out);\n\t\t\t\t\tthis.$internalParamsBuffer[j] = out[0];\n\t\t\t\t});\n\t\t\t});\n\t\t\tthis.unlock();\n\t\t\tif (!this.supportSharedArrayBuffer) {\n\t\t\t\tthis.call('setBuffer', { lock: this.$lock, paramsBuffer: this.$internalParamsBuffer });\n\t\t\t}\n\t\t\tconst { currentTime } = audioWorkletGlobalScope;\n\t\t\tlet $event;\n\t\t\tfor ($event = 0; $event < this.eventQueue.length; $event++) {\n\t\t\t\tconst event = this.eventQueue[$event];\n\t\t\t\tif (event.time && event.time > currentTime) break;\n\t\t\t\tif (typeof this.handleEvent === 'function') this.handleEvent(event);\n\t\t\t\tthis.call('dispatchWamEvent', event);\n\t\t\t}\n\t\t\tif ($event) this.eventQueue.splice(0, $event);\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * @param {string} wamInstanceId\n\t\t * @param {number} [output]\n\t\t */\n\t\tconnectEvents(wamInstanceId, output) {\n\t\t\tconst wam = audioWorkletGlobalScope.webAudioModules.processors[wamInstanceId];\n\t\t\tif (!wam) return;\n\t\t\taudioWorkletGlobalScope.webAudioModules.connectEvents(this, wam, output);\n\t\t}\n\n\t\t/**\n\t\t * @param {string} [wamInstanceId]\n\t\t * @param {number} [output]\n\t\t */\n\t\tdisconnectEvents(wamInstanceId, output) {\n\t\t\tif (typeof wamInstanceId === 'undefined') {\n\t\t\t\taudioWorkletGlobalScope.webAudioModules.disconnectEvents(this);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst wam = audioWorkletGlobalScope.webAudioModules.processors[wamInstanceId];\n\t\t\tif (!wam) return;\n\t\t\taudioWorkletGlobalScope.webAudioModules.disconnectEvents(this, wam, output);\n\t\t}\n\n\t\tdestroy() {\n\t\t\taudioWorkletGlobalScope.webAudioModules.destroy(this);\n\t\t\tthis.destroyed = true;\n\t\t\tthis.port.close();\n\t\t}\n\t}\n\ttry {\n\t\tregisterProcessor(processorId, ParamMgrProcessor);\n\t} catch (error) {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.warn(error);\n\t}\n};\nexport default processor;\n", "/** @typedef {import('@webaudiomodules/api').WamProcessor} IWamProcessor */\n/** @typedef {import('@webaudiomodules/api').WamEnv} IWamEnv */\n/** @typedef {import('@webaudiomodules/api').AudioWorkletGlobalScope} AudioWorkletGlobalScope */\n\nconst executable = () => {\n\t/**\n\t * @implements {IWamEnv}\n\t */\n\tclass WamEnv {\n\t\tconstructor() {\n\t\t\t/** @type {Map<IWamProcessor, Set<IWamProcessor>[]>} */\n\t\t\tthis._eventGraph = new Map();\n\t\t\t/** @type {Record<string, IWamProcessor>} */\n\t\t\tthis._processors = {};\n\t\t}\n\n\t\tget eventGraph() {\n\t\t\treturn this._eventGraph;\n\t\t}\n\n\t\tget processors() {\n\t\t\treturn this._processors;\n\t\t}\n\n\t\t/**\n\t\t * @param {IWamProcessor} wam\n\t\t */\n\t\tcreate(wam) {\n\t\t\tthis._processors[wam.instanceId] = wam;\n\t\t\t// console.log('create', this);\n\t\t}\n\n\t\t/**\n\t\t * @param {IWamProcessor} from\n\t\t * @param {IWamProcessor} to\n\t\t * @param {number} [output]\n\t\t */\n\t\tconnectEvents(from, to, output = 0) {\n\t\t\t/** @type {Set<IWamProcessor>[]} */\n\t\t\tlet outputMap;\n\t\t\tif (this._eventGraph.has(from)) {\n\t\t\t\toutputMap = this._eventGraph.get(from);\n\t\t\t} else {\n\t\t\t\toutputMap = [];\n\t\t\t\tthis._eventGraph.set(from, outputMap);\n\t\t\t}\n\t\t\tif (outputMap[output]) {\n\t\t\t\toutputMap[output].add(to);\n\t\t\t} else {\n\t\t\t\tconst set = new Set();\n\t\t\t\tset.add(to);\n\t\t\t\toutputMap[output] = set;\n\t\t\t}\n\t\t\t// console.log('connectEvents', this);\n\t\t}\n\n\t\t/**\n\t\t * @param {IWamProcessor} from\n\t\t * @param {IWamProcessor} [to]\n\t\t * @param {number} [output]\n\t\t */\n\t\tdisconnectEvents(from, to, output) {\n\t\t\tif (!this._eventGraph.has(from)) return;\n\t\t\tconst outputMap = this._eventGraph.get(from);\n\t\t\tif (typeof to === 'undefined') {\n\t\t\t\toutputMap.forEach((set) => {\n\t\t\t\t\tif (set) set.clear();\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (typeof output === 'undefined') {\n\t\t\t\toutputMap.forEach((set) => {\n\t\t\t\t\tif (set) set.delete(to);\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!outputMap[output]) return;\n\t\t\toutputMap[output].delete(to);\n\t\t\t// console.log('disconnectEvents', this);\n\t\t}\n\n\t\t/**\n\t\t * @param {IWamProcessor} wam\n\t\t */\n\t\tdestroy(wam) {\n\t\t\tif (this.eventGraph.has(wam)) this.eventGraph.delete(wam);\n\t\t\tthis.eventGraph.forEach((outputMap) => {\n\t\t\t\toutputMap.forEach((set) => {\n\t\t\t\t\tif (set && set.has(wam)) set.delete(wam);\n\t\t\t\t});\n\t\t\t});\n\t\t\t// console.log('destroy', this);\n\t\t}\n\t}\n\n\t/** @type {AudioWorkletGlobalScope} */\n\t// @ts-ignore\n\tconst audioWorkletGlobalScope = globalThis;\n\tif (!audioWorkletGlobalScope.webAudioModules) audioWorkletGlobalScope.webAudioModules = new WamEnv();\n\treturn WamEnv;\n};\n\n/** @type {AudioWorkletGlobalScope} */\n// @ts-ignore\nconst audioWorkletGlobalScope = globalThis;\nif (audioWorkletGlobalScope.AudioWorkletProcessor) {\n\tif (!audioWorkletGlobalScope.webAudioModules) executable();\n}\n\nexport default executable;\n", "/** @typedef {import('./types').WamDescriptor} IWamDescriptor */\n/** @typedef {import('./types').WamNode} IWamNode */\n/** @typedef {import('./types').WebAudioModule} IWebAudioModule */\n\n/**\n * WebAudioModule v2 Main Class API,\n * see d.ts file for more information.\n * @abstract\n * @implements {IWebAudioModule}\n */\nexport default class WebAudioModule {\n\tstatic get isWebAudioModuleConstructor() { throw new Error('Not Implemented.'); return null; }\n\n\tstatic async createInstance(audioContext, initialState) { throw new Error('Not Implemented.'); return null; }\n\n\tconstructor(audioContext) {}\n\n\tget isWebAudioModule() { throw new Error('Not Implemented.'); return null; }\n\n\tget audioContext() { throw new Error('Not Implemented.'); return null; }\n\tset audioContext(audioContext) { throw new Error('Not Implemented.'); }\n\n\tget audioNode() { throw new Error('Not Implemented.'); return null; }\n\tset audioNode(audioNode) { throw new Error('Not Implemented.'); }\n\n\tget initialized() { throw new Error('Not Implemented.'); return null; }\n\tset initialized(initialized) { throw new Error('Not Implemented.'); }\n\n\tget moduleId() { throw new Error('Not Implemented.'); return null; }\n\n\tget instanceId() { throw new Error('Not Implemented.'); return null; }\n\tset instanceId(instanceId) { throw new Error('Not Implemented.'); }\n\n\tget descriptor() { throw new Error('Not Implemented.'); return null; }\n\n\tget name() { throw new Error('Not Implemented.'); return null; }\n\n\tget vendor() { throw new Error('Not Implemented.'); return null; }\n\n\tasync initialize(state) { throw new Error('Not Implemented.'); return null; }\n\n\tasync createAudioNode(initialState) { throw new Error('Not Implemented.'); return null; }\n\n\tasync createGui() { throw new Error('Not Implemented.'); return null; }\n\n\tdestroyGui(gui) { throw new Error('Not Implemented.'); }\n}\n", "/** @typedef {import('@webaudiomodules/api').WamDescriptor} WamDescriptor */\n/** @typedef {import('@webaudiomodules/api').WamNode} WamNode */\n\nimport AbstractWebAudioModule from '@webaudiomodules/api/src/AbstractWebAudioModule.js';\n\nclass WebAudioModule extends AbstractWebAudioModule {\n\tstatic get isWebAudioModuleConstructor() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {BaseAudioContext} audioContext\n\t * @param {any} [initialState]\n\t * @returns {Promise<AbstractWebAudioModule<any>>}\n\t */\n\tstatic createInstance(audioContext, initialState) {\n\t\treturn new this(audioContext).initialize(initialState);\n\t}\n\n\t/** @param {BaseAudioContext} audioContext */\n\tconstructor(audioContext) {\n\t\tsuper(audioContext);\n\t\tthis._audioContext = audioContext;\n\t\tthis._initialized = false;\n\t\t/** @type {WamNode} */\n\t\tthis._audioNode = undefined;\n\t\tthis._timestamp = performance.now();\n\t\t/**\n\t\t * Url to load the plugin's GUI HTML\n\t\t * @type {string}\n\t\t */\n\t\tthis._guiModuleUrl = undefined;\n\t\t/**\n\t\t * Url to load the plugin's `descriptor.json`\n\t\t * @type {string}\n\t\t */\n\t\tthis._descriptorUrl = './descriptor.json';\n\t\t/** @type {WamDescriptor} */\n\t\tthis._descriptor = {\n\t\t\tname: `WebAudioModule_${this.constructor.name}`,\n\t\t\tvendor: 'WebAudioModuleVendor',\n\t\t\tdescription: '',\n\t\t\tversion: '0.0.0',\n\t\t\tsdkVersion: '1.0.0',\n\t\t\tthumbnail: '',\n\t\t\tkeywords: [],\n\t\t\tisInstrument: false,\n\t\t\twebsite: '',\n\t\t\thasAudioInput: true,\n\t\t\thasAudioOutput: true,\n\t\t\thasAutomationInput: true,\n\t\t\thasAutomationOutput: true,\n\t\t\thasMidiInput: true,\n\t\t\thasMidiOutput: true,\n\t\t\thasMpeInput: true,\n\t\t\thasMpeOutput: true,\n\t\t\thasOscInput: true,\n\t\t\thasOscOutput: true,\n\t\t\thasSysexInput: true,\n\t\t\thasSysexOutput: true,\n\t\t};\n\t}\n\n\tget isWebAudioModule() {\n\t\treturn true;\n\t}\n\n\tget moduleId() { return this.vendor + this.name; }\n\n\tget instanceId() { return this.moduleId + this._timestamp; }\n\n\tget descriptor() { return this._descriptor; }\n\n\tget name() { return this.descriptor.name; }\n\n\tget vendor() { return this.descriptor.vendor; }\n\n\tget audioContext() {\n\t\treturn this._audioContext;\n\t}\n\n\tget audioNode() {\n\t\tif (!this.initialized) console.warn('WAM should be initialized before getting the audioNode');\n\t\treturn this._audioNode;\n\t}\n\n\tset audioNode(node) {\n\t\tthis._audioNode = node;\n\t}\n\n\tget initialized() {\n\t\treturn this._initialized;\n\t}\n\n\tset initialized(value) {\n\t\tthis._initialized = value;\n\t}\n\n\t/**\n\t * @param {any} [initialState]\n\t * @returns {Promise<WamNode>}\n\t */\n\tasync createAudioNode(initialState) {\n\t\t// should return a subclass of WamNode\n\t\tthrow new TypeError('createAudioNode() not provided');\n\t}\n\n\t/**\n\t * @param {any} [state]\n\t * @returns {Promise<WebAudioModule>}\n\t */\n\tasync initialize(state) {\n\t\t// await this._loadDescriptor();\n\t\tif (!this._audioNode) this.audioNode = await this.createAudioNode();\n\t\tthis.initialized = true;\n\t\treturn this;\n\t}\n\n\tasync _loadGui() {\n\t\tconst url = this._guiModuleUrl;\n\t\tif (!url) throw new TypeError('Gui module not found');\n\t\t// @ts-ignore\n\t\treturn import(/* webpackIgnore: true */url);\n\t}\n\n\tasync _loadDescriptor() {\n\t\tconst url = this._descriptorUrl;\n\t\tif (!url) throw new TypeError('Descriptor not found');\n\t\tconst response = await fetch(url);\n\t\tconst descriptor = await response.json();\n\t\tObject.assign(this._descriptor, descriptor);\n\t\treturn this._descriptor;\n\t}\n\n\t/**\n\t * @returns {Promise<HTMLElement>}\n\t */\n\tasync createGui() {\n\t\tif (!this.initialized) console.warn('Plugin should be initialized before getting the gui');\n\t\t// Do not fail if no gui is present, just return undefined\n\t\tif (!this._guiModuleUrl) return undefined;\n\t\tconst { createElement } = await this._loadGui();\n\t\treturn createElement(this);\n\t}\n\n\tdestroyGui() {}\n}\n\nexport default WebAudioModule;\n", "/** @typedef {import('@webaudiomodules/api').WamParameterInfo} IWamParameterInfo */\n/** @typedef {import('@webaudiomodules/api').WamParameterType} WamParameterType */\n/** @typedef {import('@webaudiomodules/api').WamParameterConfiguration} WamParameterConfiguration */\n\n/**\n * @param {number} x\n * @param {number} e\n */\nconst normExp = (x, e) => (e === 0 ? x : x ** (1.5 ** -e));\n\n/**\n * @param {number} x\n * @param {number} e\n */\nconst denormExp = (x, e) => (e === 0 ? x : x ** (1.5 ** e));\n\n/**\n * @param {number} x\n * @param {number} min\n * @param {number} max\n */\nconst normalize = (x, min, max, e = 0) => (\n\tmin === 0 && max === 1\n\t\t? normExp(x, e)\n\t\t: normExp((x - min) / (max - min) || 0, e));\n\n/**\n * @param {any} x\n * @param {number} min\n * @param {number} max\n */\nconst denormalize = (x, min, max, e = 0) => (\n\tmin === 0 && max === 1\n\t\t? denormExp(x, e)\n\t\t: denormExp(x, e) * (max - min) + min\n);\n\n/**\n * @param {number} x\n * @param {number} min\n * @param {number} max\n */\nconst inRange = (x, min, max) => (x >= min && x <= max);\n\n/**\n * @implements {IWamParameterInfo}\n */\nexport default class WamParameterInfo {\n\t/**\n\t * @param {string} id\n\t * @param {WamParameterConfiguration} [config]\n\t */\n\tconstructor(id, config = {}) {\n\t\tlet {\n\t\t\ttype, label, defaultValue, minValue, maxValue, discreteStep, exponent, choices, units,\n\t\t} = config;\n\t\tif (type === undefined) type = 'float';\n\t\tif (label === undefined) label = '';\n\t\tif (defaultValue === undefined) defaultValue = 0;\n\t\tif (choices === undefined) choices = [];\n\t\tif (type === 'boolean' || type === 'choice') {\n\t\t\tdiscreteStep = 1;\n\t\t\tminValue = 0;\n\t\t\tif (choices.length) maxValue = choices.length - 1;\n\t\t\telse maxValue = 1;\n\t\t} else {\n\t\t\tif (minValue === undefined) minValue = 0;\n\t\t\tif (maxValue === undefined) maxValue = 1;\n\t\t\tif (discreteStep === undefined) discreteStep = 0;\n\t\t\tif (exponent === undefined) exponent = 0;\n\t\t\tif (units === undefined) units = '';\n\t\t}\n\n\t\tconst errBase = `Param config error | ${id}: `;\n\t\tif (minValue >= maxValue) throw Error(errBase.concat('minValue must be less than maxValue'));\n\t\tif (!inRange(defaultValue, minValue, maxValue)) throw Error(errBase.concat('defaultValue out of range'));\n\t\tif (discreteStep % 1 || discreteStep < 0) {\n\t\t\tthrow Error(errBase.concat('discreteStep must be a non-negative integer'));\n\t\t} else if (discreteStep > 0 && (minValue % 1 || maxValue % 1 || defaultValue % 1)) {\n\t\t\tthrow Error(errBase.concat('non-zero discreteStep requires integer minValue, maxValue, and defaultValue'));\n\t\t}\n\t\tif (type === 'choice' && !choices.length) {\n\t\t\tthrow Error(errBase.concat('choice type parameter requires list of strings in choices'));\n\t\t}\n\n\t\t/**\n\t\t * The parameter's unique identifier.\n\t\t * @readonly @type {string}\n\t\t */\n\t\tthis.id = id;\n\n\t\t/**\n\t\t * The parameter's human-readable name.\n\t\t * @readonly @type {string}\n\t\t */\n\t\tthis.label = label;\n\n\t\t/**\n\t\t * The parameter's data type.\n\t\t * @readonly @type {WamParameterType}\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t * The parameter's default value. Must be\n\t\t * within range `[minValue, maxValue]`.\n\t\t * @readonly @type {number}\n\t\t */\n\t\tthis.defaultValue = defaultValue;\n\n\t\t/**\n\t\t * The minimum valid value of the parameter's range.\n\t\t * @readonly @type {number}\n\t\t */\n\t\tthis.minValue = minValue;\n\n\t\t/**\n\t\t * The maximum valid value of the parameter's range.\n\t\t * @readonly @type {number}\n\t\t */\n\t\tthis.maxValue = maxValue;\n\n\t\t/**\n\t\t * The distance between adjacent valid integer\n\t\t * values, if applicable.\n\t\t * @readonly @type {number}\n\t\t */\n\t\tthis.discreteStep = discreteStep;\n\n\t\t/**\n\t\t * The nonlinear (exponential) skew of the parameter's\n\t\t * range, if applicable.\n\t\t *  @readonly @type {number}\n\t\t */\n\t\tthis.exponent = exponent;\n\n\t\t/**\n\t\t * A list of human-readable choices corresponding to each\n\t\t * valid integer value in the parameter's range, if applicable.\n\t\t * @readonly @type {string[]}\n\t\t */\n\t\tthis.choices = choices;\n\n\t\t/**\n\t\t * A human-readable string representing the units of the\n\t\t * parameter's range, if applicable.\n\t\t * @readonly @type {string}\n\t\t */\n\t\tthis.units = units;\n\t}\n\n\t/**\n\t * Convert a value from the parameter's denormalized range\n\t * `[minValue, maxValue]` to normalized range `[0, 1]`.\n\t * @param {number} value\n\t */\n\tnormalize(value) {\n\t\treturn normalize(value, this.minValue, this.maxValue, this.exponent);\n\t}\n\n\t/**\n\t * Convert a value from normalized range `[0, 1]` to the\n\t * parameter's denormalized range `[minValue, maxValue]`.\n\t * @param {number} valueNorm\n\t */\n\tdenormalize(valueNorm) {\n\t\treturn denormalize(valueNorm, this.minValue, this.maxValue, this.exponent);\n\t}\n\n\t/**\n\t * Get a human-readable string representing the given value,\n\t * including units if applicable.\n\t * @param {number} value\n\t */\n\tvalueString(value) {\n\t\tif (this.choices) return this.choices[value];\n\t\tif (this.units !== '') return `${value} ${this.units}`;\n\t\treturn `${value}`;\n\t}\n}\n\nif (globalThis.AudioWorkletGlobalScope) {\n\tglobalThis.WamParameterInfo = WamParameterInfo;\n}\n", "/** @typedef {import('./types').TypedArrayConstructor} TypedArrayConstructor */\n/** @typedef {import('./types').TypedArray} TypedArray */\n/** @typedef {import('./types').RingBuffer} IRingBuffer */\n/** @typedef {typeof import('./types').RingBuffer} RingBufferConstructor */\n/** @typedef {import('./types').AudioWorkletGlobalScope} AudioWorkletGlobalScope */\n\n/**\n * @returns {RingBufferConstructor}\n */\nconst executable = () => {\n\t/**\n\t * A Single Producer - Single Consumer thread-safe wait-free ring buffer.\n\t * The producer and the consumer can be on separate threads, but cannot change roles,\n\t * except with external synchronization. Adapted from https://github.com/padenot/ringbuf.js\n\t * MPL-2.0 License (see RingBuffer_LICENSE.txt)\n\t *\n\t * @implements {IRingBuffer}\n\t * @author padenot\n\t */\n\tclass RingBuffer {\n\t\t/**\n\t\t * @param {number} capacity\n\t\t * @param {TypedArrayConstructor} Type\n\t\t */\n\t\tstatic getStorageForCapacity(capacity, Type) {\n\t\t\tif (!Type.BYTES_PER_ELEMENT) {\n\t\t\t\tthrow new Error('Pass in a ArrayBuffer subclass');\n\t\t\t}\n\t\t\tconst bytes = 8 + (capacity + 1) * Type.BYTES_PER_ELEMENT;\n\t\t\treturn new SharedArrayBuffer(bytes);\n\t\t}\n\n\t\t/**\n\t\t * `sab` is a SharedArrayBuffer with a capacity calculated by calling\n\t\t * `getStorageForCapacity` with the desired capacity.\n\t\t *\n\t\t * @param {SharedArrayBuffer} sab\n\t\t * @param {TypedArrayConstructor} Type\n\t\t */\n\t\tconstructor(sab, Type) {\n\t\t\t// eslint-disable-next-line no-prototype-builtins\n\t\t\tif (!Type.BYTES_PER_ELEMENT) {\n\t\t\t\tthrow new Error('Pass a concrete typed array class as second argument');\n\t\t\t}\n\n\t\t\t// Maximum usable size is 1<<32 - type.BYTES_PER_ELEMENT bytes in the ring\n\t\t\t// buffer for this version, easily changeable.\n\t\t\t// -4 for the write ptr (uint32_t offsets)\n\t\t\t// -4 for the read ptr (uint32_t offsets)\n\t\t\t// capacity counts the empty slot to distinguish between full and empty.\n\t\t\tthis._Type = Type;\n\t\t\tthis._capacity = (sab.byteLength - 8) / Type.BYTES_PER_ELEMENT;\n\t\t\tthis.buf = sab;\n\t\t\tthis.write_ptr = new Uint32Array(this.buf, 0, 1);\n\t\t\tthis.read_ptr = new Uint32Array(this.buf, 4, 1);\n\t\t\tthis.storage = new Type(this.buf, 8, this._capacity);\n\t\t}\n\n\t\t/**\n\t\t * Returns the type of the underlying ArrayBuffer for this RingBuffer. This\n\t\t * allows implementing crude type checking.\n\t\t */\n\t\tget type() {\n\t\t\treturn this._Type.name;\n\t\t}\n\n\t\t/**\n\t\t * Push bytes to the ring buffer. `elements` is a typed array of the same type\n\t\t * as passed in the ctor, to be written to the queue.\n\t\t * Returns the number of elements written to the queue.\n\t\t *\n\t\t * @param {TypedArray} elements\n\t\t */\n\t\tpush(elements) {\n\t\t\tconst rd = Atomics.load(this.read_ptr, 0);\n\t\t\tconst wr = Atomics.load(this.write_ptr, 0);\n\n\t\t\tif ((wr + 1) % this._storageCapacity() === rd) {\n\t\t\t\t// full\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tconst toWrite = Math.min(this._availableWrite(rd, wr), elements.length);\n\t\t\tconst firstPart = Math.min(this._storageCapacity() - wr, toWrite);\n\t\t\tconst secondPart = toWrite - firstPart;\n\n\t\t\tthis._copy(elements, 0, this.storage, wr, firstPart);\n\t\t\tthis._copy(elements, firstPart, this.storage, 0, secondPart);\n\n\t\t\t// publish the enqueued data to the other side\n\t\t\tAtomics.store(\n\t\t\t\tthis.write_ptr,\n\t\t\t\t0,\n\t\t\t\t(wr + toWrite) % this._storageCapacity(),\n\t\t\t);\n\n\t\t\treturn toWrite;\n\t\t}\n\n\t\t/**\n\t\t * Read `elements.length` elements from the ring buffer if `elements` is a typed\n\t\t * array of the same type as passed in the ctor. If `elements` is an integer,\n\t\t * pop and discard that many elements from the ring buffer.\n\t\t * Returns the number of elements read from the queue, they are placed at the\n\t\t * beginning of the array passed as parameter if `elements` is not an integer.\n\t\t *\n\t\t * @param {TypedArray | number} elements\n\t\t */\n\t\tpop(elements) {\n\t\t\tconst rd = Atomics.load(this.read_ptr, 0);\n\t\t\tconst wr = Atomics.load(this.write_ptr, 0);\n\n\t\t\tif (wr === rd) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tconst isArray = !Number.isInteger(elements);\n\t\t\t// @ts-ignore\n\t\t\tconst toRead = Math.min(this._availableRead(rd, wr), isArray ? elements.length : elements);\n\n\t\t\tif (isArray) {\n\t\t\t\tconst firstPart = Math.min(this._storageCapacity() - rd, toRead);\n\t\t\t\tconst secondPart = toRead - firstPart;\n\n\t\t\t\t// @ts-ignore\n\t\t\t\tthis._copy(this.storage, rd, elements, 0, firstPart);\n\t\t\t\t// @ts-ignore\n\t\t\t\tthis._copy(this.storage, 0, elements, firstPart, secondPart);\n\t\t\t}\n\t\t\tAtomics.store(this.read_ptr, 0, (rd + toRead) % this._storageCapacity());\n\n\t\t\treturn toRead;\n\t\t}\n\n\t\t/**\n\t\t * True if the ring buffer is empty false otherwise. This can be late on the\n\t\t * reader side: it can return true even if something has just been pushed.\n\t\t */\n\t\tget empty() {\n\t\t\tconst rd = Atomics.load(this.read_ptr, 0);\n\t\t\tconst wr = Atomics.load(this.write_ptr, 0);\n\n\t\t\treturn wr === rd;\n\t\t}\n\n\t\t/**\n\t\t * True if the ring buffer is full, false otherwise. This can be late on the\n\t\t * write side: it can return true when something has just been popped.\n\t\t */\n\t\tget full() {\n\t\t\tconst rd = Atomics.load(this.read_ptr, 0);\n\t\t\tconst wr = Atomics.load(this.write_ptr, 0);\n\n\t\t\treturn (wr + 1) % this._capacity !== rd;\n\t\t}\n\n\t\t/**\n\t\t * The usable capacity for the ring buffer: the number of elements that can be\n\t\t * stored.\n\t\t */\n\t\tget capacity() {\n\t\t\treturn this._capacity - 1;\n\t\t}\n\n\t\t/**\n\t\t * Number of elements available for reading. This can be late, and report less\n\t\t * elements that is actually in the queue, when something has just been\n\t\t * enqueued.\n\t\t */\n\t\tget availableRead() {\n\t\t\tconst rd = Atomics.load(this.read_ptr, 0);\n\t\t\tconst wr = Atomics.load(this.write_ptr, 0);\n\t\t\treturn this._availableRead(rd, wr);\n\t\t}\n\n\t\t/**\n\t\t * Number of elements available for writing. This can be late, and report less\n\t\t * elements that is actually available for writing, when something has just\n\t\t * been dequeued.\n\t\t */\n\t\tget availableWrite() {\n\t\t\tconst rd = Atomics.load(this.read_ptr, 0);\n\t\t\tconst wr = Atomics.load(this.write_ptr, 0);\n\t\t\treturn this._availableWrite(rd, wr);\n\t\t}\n\n\t\t// private methods //\n\n\t\t/**\n\t\t * Number of elements available for reading, given a read and write pointer..\n\t\t *\n\t\t * @param {number} rd\n\t\t * @param {number} wr\n\t\t */\n\t\t_availableRead(rd, wr) {\n\t\t\tif (wr > rd) {\n\t\t\t\treturn wr - rd;\n\t\t\t}\n\t\t\treturn wr + this._storageCapacity() - rd;\n\t\t}\n\n\t\t/**\n\t\t * Number of elements available from writing, given a read and write pointer.\n\t\t *\n\t\t * @param {number} rd\n\t\t * @param {number} wr\n\t\t */\n\t\t_availableWrite(rd, wr) {\n\t\t\tlet rv = rd - wr - 1;\n\t\t\tif (wr >= rd) {\n\t\t\t\trv += this._storageCapacity();\n\t\t\t}\n\t\t\treturn rv;\n\t\t}\n\n\t\t/**\n\t\t * The size of the storage for elements not accounting the space for the index.\n\t\t */\n\t\t_storageCapacity() {\n\t\t\treturn this._capacity;\n\t\t}\n\n\t\t/**\n\t\t * Copy `size` elements from `input`, starting at offset `offset_input`, to\n\t\t * `output`, starting at offset `offset_output`.\n\t\t *\n\t\t * @param {TypedArray} input\n\t\t * @param {number} offsetInput\n\t\t * @param {TypedArray} output\n\t\t * @param {number} offsetOutput\n\t\t * @param {number} size\n\t\t */\n\t\t_copy(input, offsetInput, output, offsetOutput, size) {\n\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\toutput[offsetOutput + i] = input[offsetInput + i];\n\t\t\t}\n\t\t}\n\t}\n\t/** @type {AudioWorkletGlobalScope} */\n\t// @ts-ignore\n\tconst audioWorkletGlobalScope = globalThis;\n\tif (audioWorkletGlobalScope.AudioWorkletProcessor) {\n\t\tif (!audioWorkletGlobalScope.RingBuffer) audioWorkletGlobalScope.RingBuffer = RingBuffer;\n\t}\n\n\treturn RingBuffer;\n};\n/** @type {AudioWorkletGlobalScope} */\n// @ts-ignore\nconst audioWorkletGlobalScope = globalThis;\nif (audioWorkletGlobalScope.AudioWorkletProcessor) {\n\tif (!audioWorkletGlobalScope.RingBuffer) executable();\n}\n\nexport default executable;\n\n/* Usage in main thread:\nimport executable from 'RingBuffer.js';\nconst RingBuffer = executable();\n*/\n\n/* Usage in audio thread:\n// in main thread:\naudioWorklet.addModule('RingBuffer.js');\n// in audio thread\nconst { RingBuffer } = globalThis;\n*/\n\n/* Usage in audio thread with a build system:\n// in main thread:\nimport executable from 'RingBuffer.js';\nconst blob = new Blob([`(${executable.toString()})();`], { type: 'text/javascript' })\nconst url = window.URL.createObjectURL(blob);\naudioWorklet.addModule(url);\n// in audio thread\nconst { RingBuffer } = globalThis;\n*/\n", "/** @typedef {import('@webaudiomodules/api').WamEvent} WamEvent */\n/** @typedef {import('@webaudiomodules/api').WamEventType} WamEventType */\n/** @typedef {import('@webaudiomodules/api').WamAutomationEvent} WamAutomationEvent */\n/** @typedef {import('@webaudiomodules/api').WamTransportEvent} WamTransportEvent */\n/** @typedef {import('@webaudiomodules/api').WamMidiEvent} WamMidiEvent */\n/** @typedef {import('@webaudiomodules/api').WamSysexEvent} WamSysexEvent */\n/** @typedef {import('@webaudiomodules/api').WamMpeEvent} WamMpeEvent */\n/** @typedef {import('@webaudiomodules/api').WamOscEvent} WamOscEvent */\n/** @typedef {import('@webaudiomodules/api').WamInfoEvent} WamInfoEvent */\n/** @typedef {import('@webaudiomodules/api').WamParameterData} WamParameterData */\n/** @typedef {import('@webaudiomodules/api').WamTransportData} WamTransportData */\n/** @typedef {import('@webaudiomodules/api').WamMidiData} WamMidiData */\n/** @typedef {import('@webaudiomodules/api').WamBinaryData} WamBinaryData */\n/** @typedef {import('@webaudiomodules/api').WamInfoData} WamInfoData */\n/** @typedef {typeof import('./types').RingBuffer} RingBufferConstructor */\n/** @typedef {import('./types').RingBuffer} RingBuffer */\n/** @typedef {import('./types').TypedArrayConstructor} TypedArrayConstructor */\n/** @typedef {import('./types').WamEventRingBuffer} IWamEventRingBuffer */\n/** @typedef {typeof import('./types').WamEventRingBuffer} WamEventRingBufferConstructor */\n/** @typedef {import('./types').AudioWorkletGlobalScope} AudioWorkletGlobalScope */\n\n/**\n * @returns {WamEventRingBufferConstructor}\n */\nconst executable = () => {\n\t/**\n\t * @implements {IWamEventRingBuffer}\n\t */\n\tclass WamEventRingBuffer {\n\n\t\t/**\n\t\t * Default number of additional bytes allocated\n\t\t * per event (to support variable-size event objects)\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tstatic DefaultExtraBytesPerEvent = 64;\n\n\t\t/**\n\t\t * Number of bytes required for WamEventBase\n\t\t * {uint32} total event size in bytes\n\t\t * {uint8} encoded event type\n\t\t * {float64} time\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tstatic WamEventBaseBytes = 4 + 1 + 8;\n\n\t\t/**\n\t\t * Number of bytes required for WamAutomationEvent\n\t\t * {WamEventBaseBytes} common event properties\n\t\t * {uint16} encoded parameter id\n\t\t * {float64} value\n\t\t * {uint8} normalized\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tstatic WamAutomationEventBytes = WamEventRingBuffer.WamEventBaseBytes + 2 + 8 + 1;\n\n\t\t/**\n\t\t * Number of bytes required for WamTransportEvent\n\t\t * {WamEventBaseBytes} common event properties\n\t\t * {uint32} current bar\n\t\t * {float64} currentBarStarted\n\t\t * {float64} tempo\n\t\t * {uint8} time signature numerator\n\t\t * {uint8} time signature denominator\n\t\t * {uint8} playing flag\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tstatic WamTransportEventBytes = WamEventRingBuffer.WamEventBaseBytes + 4 + 8 + 8 + 1 + 1 + 1;\n\n\t\t/**\n\t\t * Number of bytes required for WamMidiEvent or WamMpeEvent\n\t\t * {WamEventBaseBytes} common event properties\n\t\t * {uint8} status byte\n\t\t * {uint8} data1 byte\n\t\t * {uint8} data2 byte\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tstatic WamMidiEventBytes = WamEventRingBuffer.WamEventBaseBytes + 1 + 1 + 1;\n\n\t\t/**\n\t\t * Number of bytes required for WamSysexEvent or WamOscEvent\n\t\t * (total number depends on content of message / size of byte array)\n\t\t * {WamEventBaseBytes} common event properties\n\t\t * {uint32} number of bytes in binary array\n\t\t * {uint8[]} N bytes in binary array depending on message\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tstatic WamBinaryEventBytes = WamEventRingBuffer.WamEventBaseBytes + 4; // + N\n\n\t\t/**\n\t\t * Returns a SharedArrayBuffer large enough to safely store\n\t\t * the specified number of events. Specify 'maxBytesPerEvent'\n\t\t * to support variable-size binary event types like sysex or osc.\n\t\t *\n\t\t * @param {RingBufferConstructor} RingBuffer\n\t\t * @param {number} eventCapacity\n\t\t * @param {number} [maxBytesPerEvent=undefined]\n\t\t * @returns {SharedArrayBuffer}\n\t\t */\n\t\tstatic getStorageForEventCapacity(RingBuffer, eventCapacity, maxBytesPerEvent = undefined) {\n\t\t\tif (maxBytesPerEvent === undefined) maxBytesPerEvent = WamEventRingBuffer.DefaultExtraBytesPerEvent;\n\t\t\telse maxBytesPerEvent = Math.max(maxBytesPerEvent, WamEventRingBuffer.DefaultExtraBytesPerEvent);\n\t\t\tconst capacity = (Math.max(\n\t\t\t\tWamEventRingBuffer.WamAutomationEventBytes,\n\t\t\t\tWamEventRingBuffer.WamTransportEventBytes,\n\t\t\t\tWamEventRingBuffer.WamMidiEventBytes,\n\t\t\t\tWamEventRingBuffer.WamBinaryEventBytes,\n\t\t\t) + maxBytesPerEvent) * eventCapacity;\n\t\t\treturn RingBuffer.getStorageForCapacity(capacity, Uint8Array);\n\t\t}\n\n\t\t/**\n\t\t * Provides methods for encoding / decoding WamEvents to / from\n\t\t * a UInt8Array RingBuffer. Specify 'maxBytesPerEvent'\n\t\t * to support variable-size binary event types like sysex or osc.\n\t\t *\n\t\t * @param {RingBufferConstructor} RingBuffer\n\t\t * @param {SharedArrayBuffer} sab\n\t\t * @param {string[]} parameterIds\n\t\t * @param {number} [maxBytesPerEvent=undefined]\n\t\t */\n\t\tconstructor(RingBuffer, sab, parameterIds, maxBytesPerEvent = undefined) {\n\t\t\t/** @type {Record<string, number>} */\n\t\t\tthis._eventSizeBytes = {};\n\n\t\t\t/** @type {Record<string, number>} */\n\t\t\tthis._encodeEventType = {};\n\n\t\t\t/** @type {Record<number, string>} */\n\t\t\tthis._decodeEventType = {};\n\t\t\t/** @type {WamEventType[]} */\n\t\t\tconst wamEventTypes = ['wam-automation', 'wam-transport', 'wam-midi', 'wam-sysex', 'wam-mpe', 'wam-osc', 'wam-info'];\n\t\t\twamEventTypes.forEach((type, encodedType) => {\n\t\t\t\tlet byteSize = 0;\n\t\t\t\tswitch (type) {\n\t\t\t\tcase 'wam-automation': byteSize = WamEventRingBuffer.WamAutomationEventBytes; break;\n\t\t\t\tcase 'wam-transport': byteSize = WamEventRingBuffer.WamTransportEventBytes; break;\n\t\t\t\tcase 'wam-mpe':\n\t\t\t\tcase 'wam-midi': byteSize = WamEventRingBuffer.WamMidiEventBytes; break;\n\t\t\t\tcase 'wam-osc':\n\t\t\t\tcase 'wam-sysex':\n\t\t\t\tcase 'wam-info': byteSize = WamEventRingBuffer.WamBinaryEventBytes; break;\n\t\t\t\tdefault: break;\n\t\t\t\t}\n\t\t\t\tthis._eventSizeBytes[type] = byteSize;\n\t\t\t\tthis._encodeEventType[type] = encodedType;\n\t\t\t\tthis._decodeEventType[encodedType] = type;\n\t\t\t});\n\n\t\t\t/** @type {number} */\n\t\t\tthis._parameterCode = 0;\n\t\t\t/** @type {{[parameterId: string]: number}} */\n\t\t\tthis._parameterCodes = {};\n\t\t\t/** @type {{[parameterId: string]: number}} */\n\t\t\tthis._encodeParameterId = {};\n\t\t\t/** @type {{[parameterId: number]: string}} */\n\t\t\tthis._decodeParameterId = {};\n\t\t\tthis.setParameterIds(parameterIds);\n\n\t\t\t/** @type {SharedArrayBuffer} */\n\t\t\tthis._sab = sab;\n\n\t\t\tif (maxBytesPerEvent === undefined) maxBytesPerEvent = WamEventRingBuffer.DefaultExtraBytesPerEvent;\n\t\t\telse maxBytesPerEvent = Math.max(maxBytesPerEvent, WamEventRingBuffer.DefaultExtraBytesPerEvent);\n\n\t\t\t/** @type {number} */\n\t\t\tthis._eventBytesAvailable = Math.max(\n\t\t\t\tWamEventRingBuffer.WamAutomationEventBytes,\n\t\t\t\tWamEventRingBuffer.WamTransportEventBytes,\n\t\t\t\tWamEventRingBuffer.WamMidiEventBytes,\n\t\t\t\tWamEventRingBuffer.WamBinaryEventBytes,\n\t\t\t) + maxBytesPerEvent;\n\t\t\t/** @type {ArrayBuffer} */\n\t\t\tthis._eventBytes = new ArrayBuffer(this._eventBytesAvailable);\n\t\t\t/** @type {DataView} */\n\t\t\tthis._eventBytesView = new DataView(this._eventBytes);\n\n\t\t\t/** @type {RingBuffer} */\n\t\t\tthis._rb = new RingBuffer(this._sab, Uint8Array);\n\n\t\t\t/** @type {Uint8Array} */\n\t\t\tthis._eventSizeArray = new Uint8Array(this._eventBytes, 0, 4);\n\n\t\t\t/** @type {DataView} */\n\t\t\tthis._eventSizeView = new DataView(this._eventBytes, 0, 4);\n\t\t}\n\n\t\t/**\n\t\t * Write common WamEvent properties to internal buffer.\n\t\t *\n\t\t * @private\n\t\t * @param {number} byteSize total size of event in bytes\n\t\t * @param {string} type\n\t\t * @param {number} time\n\t\t * @returns {number} updated byte offset\n\t\t */\n\t\t_writeHeader(byteSize, type, time) {\n\t\t\tlet byteOffset = 0;\n\t\t\tthis._eventBytesView.setUint32(byteOffset, byteSize);\n\t\t\tbyteOffset += 4;\n\t\t\tthis._eventBytesView.setUint8(byteOffset, this._encodeEventType[type]);\n\t\t\tbyteOffset += 1;\n\t\t\tthis._eventBytesView.setFloat64(byteOffset, Number.isFinite(time) ? time : -1);\n\t\t\tbyteOffset += 8;\n\t\t\treturn byteOffset;\n\t\t}\n\n\t\t/**\n\t\t * Write WamEvent to internal buffer.\n\t\t *\n\t\t * @private\n\t\t * @param {WamEvent} event\n\t\t * @returns {Uint8Array}\n\t\t */\n\t\t_encode(event) {\n\t\t\tlet byteOffset = 0;\n\t\t\tconst { type, time } = event;\n\t\t\tswitch (event.type) {\n\t\t\tcase 'wam-automation': {\n\t\t\t\tif (!(event.data.id in this._encodeParameterId)) break;\n\t\t\t\tconst byteSize = this._eventSizeBytes[type];\n\t\t\t\tbyteOffset = this._writeHeader(byteSize, type, time);\n\n\t\t\t\t/**\n\t\t\t\t * @type {WamAutomationEvent}\n\t\t\t\t * @property {WamAutomationData} data\n\t\t\t\t */\n\t\t\t\tconst { data } = event;\n\t\t\t\tconst encodedParameterId = this._encodeParameterId[data.id];\n\t\t\t\tconst { value, normalized } = data;\n\n\t\t\t\tthis._eventBytesView.setUint16(byteOffset, encodedParameterId);\n\t\t\t\tbyteOffset += 2;\n\t\t\t\tthis._eventBytesView.setFloat64(byteOffset, value);\n\t\t\t\tbyteOffset += 8;\n\t\t\t\tthis._eventBytesView.setUint8(byteOffset, normalized ? 1 : 0);\n\t\t\t\tbyteOffset += 1;\n\t\t\t} break;\n\t\t\tcase 'wam-transport': {\n\t\t\t\tconst byteSize = this._eventSizeBytes[type];\n\t\t\t\tbyteOffset = this._writeHeader(byteSize, type, time);\n\n\t\t\t\t/**\n\t\t\t\t * @type {WamTransportEvent}\n\t\t\t\t * @property {WamTransportData} data\n\t\t\t\t */\n\t\t\t\tconst { data } = event;\n\t\t\t\tconst {\n\t\t\t\t\tcurrentBar, currentBarStarted, tempo, timeSigNumerator, timeSigDenominator, playing\n\t\t\t\t} = data;\n\n\t\t\t\tthis._eventBytesView.setUint32(byteOffset, currentBar);\n\t\t\t\tbyteOffset += 4;\n\t\t\t\tthis._eventBytesView.setFloat64(byteOffset, currentBarStarted);\n\t\t\t\tbyteOffset += 8;\n\t\t\t\tthis._eventBytesView.setFloat64(byteOffset, tempo);\n\t\t\t\tbyteOffset += 8;\n\t\t\t\tthis._eventBytesView.setUint8(byteOffset, timeSigNumerator);\n\t\t\t\tbyteOffset += 1;\n\t\t\t\tthis._eventBytesView.setUint8(byteOffset, timeSigDenominator);\n\t\t\t\tbyteOffset += 1;\n\t\t\t\tthis._eventBytesView.setUint8(byteOffset, playing ? 1 : 0);\n\t\t\t\tbyteOffset += 1;\n\t\t\t} break;\n\t\t\tcase 'wam-mpe':\n\t\t\tcase 'wam-midi': {\n\t\t\t\tconst byteSize = this._eventSizeBytes[type];\n\t\t\t\tbyteOffset = this._writeHeader(byteSize, type, time);\n\n\t\t\t\t/**\n\t\t\t\t * @type {WamMidiEvent | WamMpeEvent}\n\t\t\t\t * @property {WamMidiData} data\n\t\t\t\t */\n\t\t\t\tconst { data } = event;\n\t\t\t\tconst { bytes } = data;\n\t\t\t\tlet b = 0;\n\t\t\t\twhile (b < 3) {\n\t\t\t\t\tthis._eventBytesView.setUint8(byteOffset, bytes[b]);\n\t\t\t\t\tbyteOffset += 1;\n\t\t\t\t\tb++;\n\t\t\t\t}\n\t\t\t} break;\n\t\t\tcase 'wam-osc':\n\t\t\tcase 'wam-sysex':\n\t\t\tcase 'wam-info': {\n\t\t\t\t/** @type {Uint8Array | null} */\n\t\t\t\tlet bytes = null;\n\t\t\t\tif (event.type === 'wam-info') {\n\t\t\t\t\t/**\n\t\t\t\t\t * @type {WamInfoEvent}\n\t\t\t\t\t * @property {WamInfoData} data\n\t\t\t\t\t */\n\t\t\t\t\tconst { data } = event;\n\t\t\t\t\tbytes = (new TextEncoder()).encode(data.instanceId);\n\t\t\t\t} else {\n\t\t\t\t\t/**\n\t\t\t\t\t * @type {WamSysexEvent | WamOscEvent}\n\t\t\t\t\t * @property {WamBinaryData} data\n\t\t\t\t\t */\n\t\t\t\t\tconst { data } = event;\n\t\t\t\t\tbytes = data.bytes;\n\t\t\t\t}\n\t\t\t\tconst numBytes = bytes.length;\n\t\t\t\tconst byteSize = this._eventSizeBytes[type];\n\t\t\t\tbyteOffset = this._writeHeader(byteSize + numBytes, type, time);\n\n\t\t\t\tthis._eventBytesView.setUint32(byteOffset, numBytes);\n\t\t\t\tbyteOffset += 4;\n\n\t\t\t\tconst bytesRequired = byteOffset + numBytes;\n\t\t\t\t// eslint-disable-next-line no-console\n\t\t\t\tif (bytesRequired > this._eventBytesAvailable) console.error(`Event requires ${bytesRequired} bytes but only ${this._eventBytesAvailable} have been allocated!`);\n\n\t\t\t\tconst buffer = new Uint8Array(this._eventBytes, byteOffset, numBytes);\n\t\t\t\tbuffer.set(bytes);\n\t\t\t\tbyteOffset += numBytes;\n\t\t\t} break;\n\t\t\tdefault: break;\n\t\t\t}\n\t\t\treturn new Uint8Array(this._eventBytes, 0, byteOffset);\n\t\t}\n\n\t\t/**\n\t\t * Read WamEvent from internal buffer.\n\t\t *\n\t\t * @private\n\t\t * @returns {WamEvent | false} Decoded WamEvent\n\t\t */\n\t\t_decode() {\n\t\t\tlet byteOffset = 0;\n\t\t\tconst type = this._decodeEventType[this._eventBytesView.getUint8(byteOffset)];\n\t\t\tbyteOffset += 1;\n\t\t\tlet time = this._eventBytesView.getFloat64(byteOffset);\n\t\t\tif (time === -1) time = undefined;\n\t\t\tbyteOffset += 8;\n\n\t\t\tswitch (type) {\n\t\t\tcase 'wam-automation': {\n\t\t\t\tconst encodedParameterId = this._eventBytesView.getUint16(byteOffset);\n\t\t\t\tbyteOffset += 2;\n\t\t\t\tconst value = this._eventBytesView.getFloat64(byteOffset);\n\t\t\t\tbyteOffset += 8;\n\t\t\t\tconst normalized = !!this._eventBytesView.getUint8(byteOffset);\n\t\t\t\tbyteOffset += 1;\n\n\t\t\t\tif (!(encodedParameterId in this._decodeParameterId)) break;\n\t\t\t\tconst id = this._decodeParameterId[encodedParameterId];\n\t\t\t\t/** @type {WamAutomationEvent} */\n\t\t\t\tconst event = {\n\t\t\t\t\ttype,\n\t\t\t\t\ttime,\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tid, value, normalized,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t\treturn event;\n\t\t\t}\n\t\t\tcase 'wam-transport': {\n\t\t\t\tconst currentBar = this._eventBytesView.getUint32(byteOffset);\n\t\t\t\tbyteOffset += 4;\n\t\t\t\tconst currentBarStarted = this._eventBytesView.getFloat64(byteOffset);\n\t\t\t\tbyteOffset += 8;\n\t\t\t\tconst tempo = this._eventBytesView.getFloat64(byteOffset);\n\t\t\t\tbyteOffset += 8;\n\t\t\t\tconst timeSigNumerator = this._eventBytesView.getUint8(byteOffset);\n\t\t\t\tbyteOffset += 1;\n\t\t\t\tconst timeSigDenominator = this._eventBytesView.getUint8(byteOffset);\n\t\t\t\tbyteOffset += 1;\n\t\t\t\tconst playing = (this._eventBytesView.getUint8(byteOffset) == 1);\n\t\t\t\tbyteOffset += 1;\n\n\t\t\t\t/** @type {WamTransportEvent} */\n\t\t\t\tconst event = {\n\t\t\t\t\ttype,\n\t\t\t\t\ttime,\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tcurrentBar, currentBarStarted, tempo, timeSigNumerator, timeSigDenominator, playing\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t\treturn event;\n\t\t\t}\n\t\t\tcase 'wam-mpe':\n\t\t\tcase 'wam-midi': {\n\t\t\t\t/** @type {[number, number, number]} */\n\t\t\t\tconst bytes = [0, 0, 0];\n\t\t\t\tlet b = 0;\n\t\t\t\twhile (b < 3) {\n\t\t\t\t\tbytes[b] = this._eventBytesView.getUint8(byteOffset);\n\t\t\t\t\tbyteOffset += 1;\n\t\t\t\t\tb++;\n\t\t\t\t}\n\n\t\t\t\t/** @type {WamMidiEvent | WamMpeEvent} */\n\t\t\t\tconst event = {\n\t\t\t\t\ttype,\n\t\t\t\t\ttime,\n\t\t\t\t\tdata: { bytes },\n\t\t\t\t};\n\t\t\t\treturn event;\n\t\t\t}\n\t\t\tcase 'wam-osc':\n\t\t\tcase 'wam-sysex':\n\t\t\tcase 'wam-info': {\n\t\t\t\tconst numBytes = this._eventBytesView.getUint32(byteOffset);\n\t\t\t\tbyteOffset += 4;\n\t\t\t\tconst bytes = new Uint8Array(numBytes);\n\t\t\t\tbytes.set(new Uint8Array(this._eventBytes, byteOffset, numBytes));\n\t\t\t\tbyteOffset += numBytes;\n\n\t\t\t\tif (type === 'wam-info') {\n\t\t\t\t\tconst instanceId = (new TextDecoder()).decode(bytes);\n\t\t\t\t\tconst data = { instanceId };\n\t\t\t\t\treturn { type, time, data };\n\t\t\t\t} else {\n\t\t\t\t\tconst data = { bytes };\n\t\t\t\t\treturn { type, time, data };\n\t\t\t\t}\n\t\t\t}\n\t\t\tdefault: break;\n\t\t\t}\n\t\t\t// eslint-disable-next-line no-console\n\t\t\t// console.warn('Failed to decode event!');\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * Write WamEvents to the ring buffer, returning\n\t\t * the number of events successfully written.\n\t\t *\n\t\t * @param {WamEvent[]} events\n\t\t * @returns {number}\n\t\t */\n\t\twrite(...events) {\n\t\t\tconst numEvents = events.length;\n\t\t\tlet bytesAvailable = this._rb.availableWrite;\n\t\t\tlet numSkipped = 0;\n\t\t\tlet i = 0;\n\t\t\twhile (i < numEvents) {\n\t\t\t\tconst event = events[i];\n\t\t\t\tconst bytes = this._encode(event);\n\t\t\t\tconst eventSizeBytes = bytes.byteLength;\n\n\t\t\t\tlet bytesWritten = 0;\n\t\t\t\tif (bytesAvailable >= eventSizeBytes) {\n\t\t\t\t\tif (eventSizeBytes === 0) numSkipped++;\n\t\t\t\t\telse bytesWritten = this._rb.push(bytes);\n\t\t\t\t} else break;\n\t\t\t\tbytesAvailable -= bytesWritten;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\treturn i - numSkipped;\n\t\t}\n\n\t\t/**\n\t\t * Read WamEvents from the ring buffer, returning\n\t\t * the list of events successfully read.\n\t\t *\n\t\t * @returns {WamEvent[]}\n\t\t */\n\t\tread() {\n\t\t\tif (this._rb.empty) return [];\n\t\t\tconst events = [];\n\t\t\tlet bytesAvailable = this._rb.availableRead;\n\t\t\tlet bytesRead = 0;\n\t\t\twhile (bytesAvailable > 0) {\n\t\t\t\tbytesRead = this._rb.pop(this._eventSizeArray);\n\t\t\t\tbytesAvailable -= bytesRead;\n\t\t\t\tconst eventSizeBytes = this._eventSizeView.getUint32(0);\n\t\t\t\tconst eventBytes = new Uint8Array(this._eventBytes, 0, eventSizeBytes - 4);\n\t\t\t\tbytesRead = this._rb.pop(eventBytes);\n\t\t\t\tbytesAvailable -= bytesRead;\n\t\t\t\tconst decodedEvent = this._decode();\n\t\t\t\tif (decodedEvent) events.push(decodedEvent);\n\t\t\t}\n\t\t\treturn events;\n\t\t}\n\n\t\t/**\n\t\t * In case parameter set changes, update the internal mappings.\n\t\t * May result in some invalid automation events, which will be\n\t \t * ignored. Note that this must be called on all corresponding\n\t\t * WamEventRingBuffers on both threads.\n\t\t * @param {string[]} parameterIds\n\t\t */\n\t\tsetParameterIds(parameterIds) {\n\t\t\tthis._encodeParameterId = {};\n\t\t\tthis._decodeParameterId = {};\n\t\t\tparameterIds.forEach((parameterId) => {\n\t\t\t\tlet parameterCode = -1\n\t\t\t\tif (parameterId in this._parameterCodes) parameterCode = this._parameterCodes[parameterId];\n\t\t\t\telse {\n\t\t\t\t\tparameterCode = this._generateParameterCode();\n\t\t\t\t\tthis._parameterCodes[parameterId] = parameterCode;\n\t\t\t\t}\n\t\t\t\tthis._encodeParameterId[parameterId] = parameterCode;\n\t\t\t\tthis._decodeParameterId[parameterCode] = parameterId;\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Generates a numeric parameter code in a range suitable for\n\t\t * encoding as uint16.\n\t\t *\n\t\t * @returns {number}\n\t\t */\n\t\t_generateParameterCode() {\n\t\t\tif (this._parameterCode > 65535) throw Error('Too many parameters have been registered!');\n\t\t\treturn this._parameterCode++;\n\t\t}\n\n\t}\n\t/** @type {AudioWorkletGlobalScope} */\n\t// @ts-ignore\n\tconst audioWorkletGlobalScope = globalThis;\n\tif (audioWorkletGlobalScope.AudioWorkletProcessor) {\n\t\tif (!audioWorkletGlobalScope.WamEventRingBuffer) {\n\t\t\taudioWorkletGlobalScope.WamEventRingBuffer = WamEventRingBuffer;\n\t\t}\n\t}\n\n\treturn WamEventRingBuffer;\n};\n/** @type {AudioWorkletGlobalScope} */\n// @ts-ignore\nconst audioWorkletGlobalScope = globalThis;\nif (audioWorkletGlobalScope.AudioWorkletProcessor) {\n\tif (!audioWorkletGlobalScope.WamEventRingBuffer) executable();\n}\n\nexport default executable;\n", "/** @typedef {import('@webaudiomodules/api').WamNode} IWamNode */\n/** @typedef {import('@webaudiomodules/api').WebAudioModule} WebAudioModule */\n/** @typedef {import('@webaudiomodules/api').WamParameterInfoMap} WamParameterInfoMap */\n/** @typedef {import('@webaudiomodules/api').WamParameterDataMap} WamParameterDataMap */\n/** @typedef {import('@webaudiomodules/api').WamEvent} WamEvent */\n/** @typedef {import('@webaudiomodules/api').WamEventType} WamEventType */\n/** @typedef {import('./types').WamEventRingBuffer} WamEventRingBuffer */\n\nimport getRingBuffer from './RingBuffer.js';\nimport getWamEventRingBuffer from './WamEventRingBuffer.js';\n\nconst RingBuffer = getRingBuffer();\nconst WamEventRingBuffer = getWamEventRingBuffer();\n\n/**\n * @implements {IWamNode}\n */\nexport default class WamNode extends AudioWorkletNode {\n\t/**\n\t * Register scripts required for the processor. Must be called before constructor.\n\t * @param {BaseAudioContext} audioContext\n\t * @param {string} baseURL\n\t */\n\tstatic async addModules(audioContext, baseURL) {\n\t\tawait audioContext.audioWorklet.addModule(`${baseURL}/../../sdk/src/RingBuffer.js`);\n\t\tawait audioContext.audioWorklet.addModule(`${baseURL}/../../sdk/src/WamEventRingBuffer.js`);\n\t\tawait audioContext.audioWorklet.addModule(`${baseURL}/../../sdk/src/WamArrayRingBuffer.js`);\n\t\tawait audioContext.audioWorklet.addModule(`${baseURL}/../../sdk/src/WamEnv.js`);\n\t\tawait audioContext.audioWorklet.addModule(`${baseURL}/../../sdk/src/WamParameter.js`);\n\t\tawait audioContext.audioWorklet.addModule(`${baseURL}/../../sdk/src/WamParameterInfo.js`);\n\t\tawait audioContext.audioWorklet.addModule(`${baseURL}/../../sdk/src/WamParameterInterpolator.js`);\n\t\tawait audioContext.audioWorklet.addModule(`${baseURL}/../../sdk/src/WamProcessor.js`);\n\t}\n\n\t/**\n\t * @param {WebAudioModule} module\n\t * @param {AudioWorkletNodeOptions} options\n\t */\n\tconstructor(module, options) {\n\t\tconst { audioContext, moduleId, instanceId } = module;\n\t\toptions.processorOptions = {\n\t\t\tmoduleId,\n\t\t\tinstanceId,\n\t\t\t...options.processorOptions,\n\t\t};\n\t\tsuper(audioContext, moduleId, options);\n\n\t\t/** @type {WebAudioModule} */\n\t\tthis.module = module;\n\t\t/** @private @type {Set<WamEventType>} */\n\t\tthis._supportedEventTypes = new Set(['wam-automation', 'wam-transport', 'wam-midi', 'wam-sysex', 'wam-mpe', 'wam-osc']);\n\t\t/** @private @type {number} */\n\t\tthis._messageId = 1;\n\t\t/** @private @type {Record<number, (...args: any[]) => any>} */\n\t\tthis._pendingResponses = {};\n\t\t/** @private @type {Record<number, () => any>} */\n\t\tthis._pendingEvents = {};\n\t\t/** @private @type {boolean} */\n\t\tthis._useSab = false; // can override this via processorOptions;\n\t\t/** @private @type {boolean} */\n\t\tthis._eventSabReady = false;\n\t\t/** @private @type {boolean} */\n\t\tthis._destroyed = false;\n\n\t\tthis.port.onmessage = this._onMessage.bind(this);\n\t}\n\n\t/** @returns {string} */\n\tget moduleId() { return this.module.moduleId; }\n\t/** @returns {string} */\n\tget instanceId() { return this.module.instanceId; }\n\t/** @returns {string} */\n\tget processorId() { return this.moduleId; }\n\n\t/**\n\t * Get parameter info for the specified parameter ids,\n\t * or omit argument to get info for all parameters.\n\t * @param {string[]} parameterIds\n\t * @returns {Promise<WamParameterInfoMap>}\n\t */\n\tasync getParameterInfo(...parameterIds) {\n\t\tconst request = 'get/parameterInfo';\n\t\tconst id = this._generateMessageId();\n\t\treturn new Promise((resolve) => {\n\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\tthis.port.postMessage({\n\t\t\t\tid,\n\t\t\t\trequest,\n\t\t\t\tcontent: { parameterIds },\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Get parameter values for the specified parameter ids,\n\t * or omit argument to get values for all parameters.\n\t * @param {boolean} normalized\n\t * @param {string[]} parameterIds\n\t * @returns {Promise<WamParameterDataMap>}\n\t */\n\tasync getParameterValues(normalized, ...parameterIds) {\n\t\tconst request = 'get/parameterValues';\n\t\tconst id = this._generateMessageId();\n\t\treturn new Promise((resolve) => {\n\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\tthis.port.postMessage({\n\t\t\t\tid,\n\t\t\t\trequest,\n\t\t\t\tcontent: { normalized, parameterIds },\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Set parameter values for the specified parameter ids.\n\t * @param {WamParameterDataMap} parameterValues\n\t * @returns {Promise<void>}\n\t */\n\tasync setParameterValues(parameterValues) {\n\t\tconst request = 'set/parameterValues';\n\t\tconst id = this._generateMessageId();\n\t\treturn new Promise((resolve) => {\n\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\tthis.port.postMessage({\n\t\t\t\tid,\n\t\t\t\trequest,\n\t\t\t\tcontent: { parameterValues },\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Returns an object (such as JSON or a serialized blob)\n\t * that can be used to restore the WAM's state.\n\t * @returns {Promise<any>}\n\t */\n\tasync getState() {\n\t\tconst request = 'get/state';\n\t\t// perhaps the only info to request from processor is param state?\n\t\tconst id = this._generateMessageId();\n\t\treturn new Promise((resolve) => {\n\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\tthis.port.postMessage({ id, request });\n\t\t});\n\t}\n\n\t/**\n\t * Use an object (such as JSON or a serialized blob)\n\t * to restore the WAM's state.\n\t * @param {any} state\n\t */\n\tasync setState(state) {\n\t\tconst request = 'set/state';\n\t\tconst id = this._generateMessageId();\n\t\t// perhaps the only info to send to processor is param state?\n\t\treturn new Promise((resolve) => {\n\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\tthis.port.postMessage({\n\t\t\t\tid,\n\t\t\t\trequest,\n\t\t\t\tcontent: { state },\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Compensation delay hint in seconds.\n\t * @returns {Promise<number>}\n\t */\n\tasync getCompensationDelay() {\n\t\tconst request = 'get/compensationDelay';\n\t\tconst id = this._generateMessageId();\n\t\treturn new Promise((resolve) => {\n\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\tthis.port.postMessage({ id, request });\n\t\t});\n\t}\n\n\t/**\n\t * Register a callback function so it will be called\n\t * when matching events are processed.\n\t * @param {WamEventType} type\n\t * @param {EventListenerOrEventListenerObject | null} callback\n\t * @param {AddEventListenerOptions | boolean} options;\n\t */\n\taddEventListener(type, callback, options) {\n\t\tif (this._supportedEventTypes.has(type)) super.addEventListener(type, callback, options);\n\t}\n\n\t/**\n\t * Deregister a callback function so it will no longer\n\t * be called when matching events are processed.\n\t * @param {WamEventType} type\n\t * @param {EventListenerOrEventListenerObject | null} callback\n\t * @param {AddEventListenerOptions | boolean} options;\n\t */\n\tremoveEventListener(type, callback, options) {\n\t\tif (this._supportedEventTypes.has(type)) super.removeEventListener(type, callback, options);\n\t}\n\n\t/**\n\t * From the main thread, schedule a WamEvent.\n\t * Listeners will be triggered when the event is processed.\n\t * @param {WamEvent[]} events\n\t */\n\tscheduleEvents(...events) {\n\t\tlet i = 0;\n\t\tconst numEvents = events.length;\n\t\tif (this._eventSabReady) {\n\t\t\ti = this._eventWriter.write(...events);\n\t\t\t// fall back on message port if ring buffer gets full\n\t\t}\n\t\twhile (i < numEvents) {\n\t\t\tconst event = events[i];\n\t\t\tconst request = 'add/event';\n\t\t\tconst id = this._generateMessageId();\n\t\t\tlet processed = false;\n\t\t\tnew Promise((resolve, reject) => {\n\t\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\t\tthis._pendingEvents[id] = () => { if (!processed) reject(); };\n\t\t\t\tthis.port.postMessage({\n\t\t\t\t\tid,\n\t\t\t\t\trequest,\n\t\t\t\t\tcontent: { event },\n\t\t\t\t});\n\t\t\t}).then((resolved) => {\n\t\t\t\tprocessed = true;\n\t\t\t\tdelete this._pendingEvents[id];\n\t\t\t\tthis._onEvent(event);\n\t\t\t}).catch((rejected) => { delete this._pendingResponses[id]; });\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/** From the main thread, clear all pending WamEvents. */\n\tasync clearEvents() {\n\t\tconst request = 'remove/events';\n\t\tconst id = this._generateMessageId();\n\t\treturn new Promise((resolve) => {\n\t\t\tconst ids = Object.keys(this._pendingEvents);\n\t\t\tif (ids.length) {\n\t\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\t\tthis.port.postMessage({ id, request });\n\t\t\t}\n\t\t}).then((clearedIds) => {\n\t\t\tclearedIds.forEach((clearedId) => {\n\t\t\t\tthis._pendingEvents[clearedId]();\n\t\t\t\tdelete this._pendingEvents[clearedId];\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @param {WamNode} to the destination WAM for the event stream\n\t * @param {number} [output] the event output stream of the source WAM\n\t */\n\tconnectEvents(to, output) {\n\t\tif (!to.module?.isWebAudioModule) return;\n\t\tconst request = 'connect/events';\n\t\tconst id = this._generateMessageId();\n\t\tnew Promise((resolve, reject) => {\n\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\tthis.port.postMessage({\n\t\t\t\tid,\n\t\t\t\trequest,\n\t\t\t\tcontent: { wamInstanceId: to.instanceId, output },\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @param {WamNode} [to] the destination WAM for the event stream\n\t * @param {number} [output]\n\t */\n\tdisconnectEvents(to, output) {\n\t\tif (to && !to.module?.isWebAudioModule) return;\n\t\tconst request = 'disconnect/events';\n\t\tconst id = this._generateMessageId();\n\t\tnew Promise((resolve, reject) => {\n\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\tthis.port.postMessage({\n\t\t\t\tid,\n\t\t\t\trequest,\n\t\t\t\tcontent: { wamInstanceId: to?.instanceId, output },\n\t\t\t});\n\t\t});\n\t}\n\n\t/** Stop processing and remove the node from the graph. */\n\tdestroy() {\n\t\tif (this._audioToMainInterval) clearInterval(this._audioToMainInterval);\n\t\tthis.port.postMessage({ destroy: true });\n\t\tthis.port.close();\n\t\tthis.disconnect();\n\t\tthis._destroyed = true;\n\t}\n\n\t_generateMessageId() {\n\t\t/* eslint-disable-next-line no-plusplus */\n\t\treturn this._messageId++;\n\t}\n\n\t/**\n\t * Post-constructor (asynchronous) initialization method.\n\t */\n\tasync _initialize() {\n\t\tconst request = 'initialize/processor';\n\t\tconst id = this._generateMessageId();\n\t\treturn new Promise((resolve) => {\n\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\tthis.port.postMessage({ id, request });\n\t\t});\n\t}\n\n\t/**\n\t * Messages from audio thread\n\t * @param {MessageEvent} message\n\t * */\n\t_onMessage(message) {\n\t\tconst { data } = message;\n\t\tconst { response, event, eventSab } = data;\n\t\tif (response) {\n\t\t\tconst { id, content } = data;\n\t\t\tconst resolvePendingResponse = this._pendingResponses[id];\n\t\t\tif (resolvePendingResponse) {\n\t\t\t\tdelete this._pendingResponses[id];\n\t\t\t\tresolvePendingResponse(content);\n\t\t\t}\n\t\t\t// else console.log(`unhandled message | response: ${response} content: ${content}`);\n\t\t} else if (eventSab) {\n\t\t\tthis._useSab = true;\n\t\t\tconst { eventCapacity, parameterIds } = eventSab;\n\n\t\t\tif (this._eventSabReady) {\n\t\t\t\t// if parameter set changes after initialization\n\t\t\t\tthis._eventWriter.setParameterIds(parameterIds);\n\t\t\t\tthis._eventReader.setParameterIds(parameterIds);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/** @private @type {SharedArrayBuffer} */\n\t\t\tthis._mainToAudioEventSab = WamEventRingBuffer.getStorageForEventCapacity(RingBuffer,\n\t\t\t\teventCapacity);\n\n\t\t\t/** @private @type {SharedArrayBuffer} */\n\t\t\tthis._audioToMainEventSab = WamEventRingBuffer.getStorageForEventCapacity(RingBuffer,\n\t\t\t\teventCapacity);\n\n\t\t\t/** @private @type {WamEventRingBuffer} */\n\t\t\tthis._eventWriter = new WamEventRingBuffer(RingBuffer, this._mainToAudioEventSab,\n\t\t\t\tparameterIds);\n\t\t\t/** @private @type {WamEventRingBuffer} */\n\t\t\tthis._eventReader = new WamEventRingBuffer(RingBuffer, this._audioToMainEventSab,\n\t\t\t\tparameterIds);\n\n\t\t\tconst request = 'initialize/eventSab';\n\t\t\tconst id = this._generateMessageId();\n\t\t\tnew Promise((resolve, reject) => {\n\t\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\t\tthis.port.postMessage({\n\t\t\t\t\tid,\n\t\t\t\t\trequest,\n\t\t\t\t\tcontent: {\n\t\t\t\t\t\tmainToAudioEventSab: this._mainToAudioEventSab,\n\t\t\t\t\t\taudioToMainEventSab: this._audioToMainEventSab,\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t}).then((resolved) => {\n\t\t\t\tthis._eventSabReady = true;\n\n\t\t\t\t// periodically check for messages from audio thread\n\t\t\t\tthis._audioToMainInterval = setInterval(() => {\n\t\t\t\t\tconst events = this._eventReader.read();\n\t\t\t\t\tevents.forEach((e) => { this._onEvent(e); });\n\t\t\t\t}, 100);\n\t\t\t});\n\t\t} else if (event) this._onEvent(event);\n\t}\n\n\t_onEvent(event) {\n\t\tconst { type } = event;\n\t\tthis.dispatchEvent(new CustomEvent(type, {\n\t\t\tbubbles: true,\n\t\t\tdetail: event,\n\t\t}));\n\t}\n}\n", "/** @typedef {import('@webaudiomodules/api').WamParameterConfiguration} WamParameterConfiguration */\n/** @typedef {import('@webaudiomodules/api').WamParameterInfoMap} WamParameterInfoMap */\n/** @typedef {import('./types').ParametersMapping} ParametersMapping */\n/** @typedef {import('./types').InternalParametersDescriptor} InternalParametersDescriptor */\n/** @typedef {import('./types').ParametersMappingConfiguratorOptions} ParametersMappingConfiguratorOptions */\n\nimport { WamParameterInfo } from '@webaudiomodules/sdk';\n\nexport default class ParamMappingConfigurator {\n\t/**\n\t * @param {ParametersMappingConfiguratorOptions} [options = {}]\n\t */\n\tconstructor(options = {}) {\n\t\tconst { paramsConfig, paramsMapping, internalParamsConfig } = options;\n\t\tthis._paramsConfig = paramsConfig;\n\t\tthis._paramsMapping = paramsMapping;\n\t\tthis._internalParamsConfig = internalParamsConfig;\n\t}\n\n\t/**\n\t * @private\n\t * @type {Record<string, WamParameterConfiguration>}\n\t */\n\t_paramsConfig = undefined;\n\n\t/**\n\t * Auto-completed `paramsConfig`:\n\t *\n\t * if no `paramsConfig` is defined while initializing, this will be be filled from the internalParamsConfig;\n\t *\n\t * if a parameter is not fully configured, the incompleted properties will have the same value as in the internalParamsConfig.\n\t *\n\t * @type {WamParameterInfoMap}\n\t */\n\tget paramsConfig() {\n\t\tconst { internalParamsConfig } = this;\n\t\treturn Object.entries(this._paramsConfig || internalParamsConfig)\n\t\t\t.reduce((configs, [id, config]) => {\n\t\t\t\tconst internalParam = internalParamsConfig[id];\n\t\t\t\tconfigs[id] = new WamParameterInfo(id, {\n\t\t\t\t\t...config,\n\t\t\t\t\tlabel: config.label ?? id,\n\t\t\t\t\tdefaultValue: config.defaultValue ?? internalParam?.defaultValue,\n\t\t\t\t\tminValue: config.minValue ?? internalParam?.minValue,\n\t\t\t\t\tmaxValue: config.maxValue ?? internalParam?.maxValue,\n\t\t\t\t});\n\t\t\t\treturn configs;\n\t\t\t}, {});\n\t}\n\n\t/**\n\t * @private\n\t * @type {InternalParametersDescriptor}\n\t */\n\t_internalParamsConfig = undefined;\n\n\t/**\n\t * Auto-completed configuration of the `internalParamsConfig`\n\t *\n\t * Internal Parameters Config contains all the automatable parameters' information.\n\t *\n\t * An automatable parameter could be a `WebAudio` `AudioParam`\n\t * or a config with an `onChange` callback that will be called while the value has been changed.\n\t *\n\t * @type {InternalParametersDescriptor}\n\t */\n\tget internalParamsConfig() {\n\t\treturn Object.entries(this._internalParamsConfig || {})\n\t\t\t.reduce((configs, [name, config]) => {\n\t\t\t\tif (config instanceof AudioParam) configs[name] = config;\n\t\t\t\telse {\n\t\t\t\t\tconst defaultConfig = {\n\t\t\t\t\t\tminValue: 0,\n\t\t\t\t\t\tmaxValue: 1,\n\t\t\t\t\t\tdefaultValue: 0,\n\t\t\t\t\t\tautomationRate: 30,\n\t\t\t\t\t};\n\t\t\t\t\tconfigs[name] = { ...defaultConfig, ...config };\n\t\t\t\t}\n\t\t\t\treturn configs;\n\t\t\t}, {});\n\t}\n\n\t/**\n\t * @private\n\t * @type {ParametersMapping}\n\t */\n\t_paramsMapping = {}\n\n\t/**\n\t * Auto-completed `paramsMapping`,\n\t * the mapping can be omitted while initialized,\n\t * but is useful when an exposed param (in the `paramsConfig`) should automate\n\t * several internal params (in the `internalParamsConfig`) or has a different range there.\n\t *\n\t * If a parameter is present in both `paramsConfig` and `internalParamsConfig` (or the `paramsConfig` is not configured),\n\t * a map of this parameter will be there automatically, if not declared explicitly.\n\t *\n\t * @type {ParametersMapping}\n\t */\n\tget paramsMapping() {\n\t\tconst declared = this._paramsMapping || {};\n\t\tconst externalParams = this.paramsConfig;\n\t\tconst internalParams = this.internalParamsConfig;\n\t\treturn Object.entries(externalParams)\n\t\t\t.reduce((mapping, [name, { minValue, maxValue }]) => {\n\t\t\t\tconst sourceRange = [minValue, maxValue];\n\t\t\t\tconst defaultMapping = { sourceRange, targetRange: [...sourceRange] };\n\t\t\t\tif (declared[name]) {\n\t\t\t\t\tconst declaredTargets = Object.entries(declared[name])\n\t\t\t\t\t\t.reduce((targets, [targetName, targetMapping]) => {\n\t\t\t\t\t\t\tif (internalParams[targetName]) {\n\t\t\t\t\t\t\t\ttargets[targetName] = { ...defaultMapping, ...targetMapping };\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn targets;\n\t\t\t\t\t\t}, {});\n\t\t\t\t\tmapping[name] = declaredTargets;\n\t\t\t\t} else if (internalParams[name]) {\n\t\t\t\t\tmapping[name] = { [name]: { ...defaultMapping } };\n\t\t\t\t}\n\t\t\t\treturn mapping;\n\t\t\t}, {});\n\t}\n}\n", "/** @typedef {import('@webaudiomodules/api').WamParameter} WamParameter */\n/** @typedef {import('@webaudiomodules/api').WamParameterInfo} WamParameterInfo */\n\n/**\n * @extends {AudioParam}\n * @implements {WamParameter}\n */\nexport default class MgrAudioParam extends AudioParam {\n\tget exponent() {\n\t\treturn this.info.exponent;\n\t}\n\n\t/**\n\t * @type {WamParameterInfo}\n\t */\n\t_info = undefined;\n\n\tget info() {\n\t\treturn this._info;\n\t}\n\n\tset info(info) {\n\t\tthis._info = info;\n\t}\n\n\tset normalizedValue(valueIn) {\n\t\tthis.value = this.info.denormalize(valueIn);\n\t}\n\n\tget normalizedValue() {\n\t\treturn this.info.normalize(this.value);\n\t}\n\n\tsetValueAtTime(value, startTime) {\n\t\treturn super.setValueAtTime(value, startTime);\n\t}\n\n\tsetNormalizedValueAtTime(valueIn, startTime) {\n\t\tconst value = this.info.denormalize(valueIn);\n\t\treturn this.setValueAtTime(value, startTime);\n\t}\n\n\tlinearRampToValueAtTime(value, endTime) {\n\t\treturn super.linearRampToValueAtTime(value, endTime);\n\t}\n\n\tlinearRampToNormalizedValueAtTime(valueIn, endTime) {\n\t\tconst value = this.info.denormalize(valueIn);\n\t\treturn this.linearRampToValueAtTime(value, endTime);\n\t}\n\n\texponentialRampToValueAtTime(value, endTime) {\n\t\treturn super.exponentialRampToValueAtTime(value, endTime);\n\t}\n\n\texponentialRampToNormalizedValueAtTime(valueIn, endTime) {\n\t\tconst value = this.info.denormalize(valueIn);\n\t\treturn this.exponentialRampToValueAtTime(value, endTime);\n\t}\n\n\tsetTargetAtTime(target, startTime, timeConstant) {\n\t\treturn super.setTargetAtTime(target, startTime, timeConstant);\n\t}\n\n\tsetNormalizedTargetAtTime(targetIn, startTime, timeConstant) {\n\t\tconst target = this.info.denormalize(targetIn);\n\t\treturn this.setTargetAtTime(target, startTime, timeConstant);\n\t}\n\n\tsetValueCurveAtTime(values, startTime, duration) {\n\t\treturn super.setValueCurveAtTime(values, startTime, duration);\n\t}\n\n\tsetNormalizedValueCurveAtTime(valuesIn, startTime, duration) {\n\t\tconst values = Array.from(valuesIn).map((v) => this.info.denormalize(v));\n\t\treturn this.setValueCurveAtTime(values, startTime, duration);\n\t}\n\n\tcancelScheduledParamValues(cancelTime) {\n\t\treturn super.cancelScheduledValues(cancelTime);\n\t}\n\n\tcancelAndHoldParamAtTime(cancelTime) {\n\t\treturn super.cancelAndHoldAtTime(cancelTime);\n\t}\n}\n", "import MgrAudioParam from './MgrAudioParam.js';\n\n/** @typedef {import('@webaudiomodules/api').WebAudioModule} WebAudioModule */\n/** @typedef {import('@webaudiomodules/api').WamNode} WamNode */\n/** @typedef {import('@webaudiomodules/api').WamParameterDataMap} WamParameterValueMap */\n/** @typedef {import('@webaudiomodules/api').WamEvent} WamEvent */\n/** @typedef {import('@webaudiomodules/api').WamAutomationEvent} WamAutomationEvent */\n/** @typedef {import('./types').ParamMgrOptions} ParamMgrOptions */\n/** @typedef {import('./types').ParamMgrCallFromProcessor} ParamMgrCallFromProcessor */\n/** @typedef {import('./types').ParamMgrCallToProcessor} ParamMgrCallToProcessor */\n/** @typedef {import('./types').ParamMgrNodeMsgIn} ParamMgrNodeMsgIn */\n/** @typedef {import('./types').ParamMgrNodeMsgOut} ParamMgrNodeMsgOut */\n/** @typedef {import('./types').ParamMgrNode} IParamMgrNode */\n\n/** @type {typeof import('./TypedAudioWorklet').TypedAudioWorkletNode} */\n// @ts-ignore\nconst AudioWorkletNode = globalThis.AudioWorkletNode;\n\n/**\n * @extends {AudioWorkletNode<ParamMgrNodeMsgIn, ParamMgrNodeMsgOut>}\n * @implements {IParamMgrNode}\n */\nexport default class ParamMgrNode extends AudioWorkletNode {\n\t/**\n     * @param {WebAudioModule} module\n     * @param {ParamMgrOptions} options\n     */\n\tconstructor(module, options) {\n\t\tsuper(module.audioContext, module.moduleId, {\n\t\t\tnumberOfInputs: 0,\n\t\t\tnumberOfOutputs: 1 + options.processorOptions.internalParams.length,\n\t\t\tparameterData: options.parameterData,\n\t\t\tprocessorOptions: options.processorOptions,\n\t\t});\n\t\tconst { processorOptions, internalParamsConfig } = options;\n\t\tthis.initialized = false;\n\t\tthis.module = module;\n\t\tthis.paramsConfig = processorOptions.paramsConfig;\n\t\tthis.internalParams = processorOptions.internalParams;\n\t\tthis.internalParamsConfig = internalParamsConfig;\n\t\tthis.$prevParamsBuffer = new Float32Array(this.internalParams.length);\n\t\tthis.paramsUpdateCheckFn = [];\n\t\tthis.paramsUpdateCheckFnRef = [];\n\t\tthis.messageRequestId = 0;\n\n\t\tObject.entries(this.getParams()).forEach(([name, param]) => {\n\t\t\tObject.setPrototypeOf(param, MgrAudioParam.prototype);\n\t\t\tparam._info = this.paramsConfig[name];\n\t\t});\n\n\t\t/** @type {Record<number, ((...args: any[]) => any)>} */\n\t\tconst resolves = {};\n\t\t/** @type {Record<number, ((...args: any[]) => any)>} */\n\t\tconst rejects = {};\n\t\t/**\n\t\t * @param {keyof ParamMgrCallToProcessor} call\n\t\t * @param {any} args\n\t\t */\n\t\tthis.call = (call, ...args) => {\n\t\t\tconst id = this.messageRequestId;\n\t\t\tthis.messageRequestId += 1;\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tresolves[id] = resolve;\n\t\t\t\trejects[id] = reject;\n\t\t\t\tthis.port.postMessage({ id, call, args });\n\t\t\t});\n\t\t};\n\t\tthis.handleMessage = ({ data }) => {\n\t\t\tconst { id, call, args, value, error } = data;\n\t\t\tif (call) {\n\t\t\t\t/** @type {any} */\n\t\t\t\tconst r = { id };\n\t\t\t\ttry {\n\t\t\t\t\tr.value = this[call](...args);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tr.error = e;\n\t\t\t\t}\n\t\t\t\tthis.port.postMessage(r);\n\t\t\t} else {\n\t\t\t\tif (error) {\n\t\t\t\t\tif (rejects[id]) rejects[id](error);\n\t\t\t\t\tdelete rejects[id];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (resolves[id]) {\n\t\t\t\t\tresolves[id](value);\n\t\t\t\t\tdelete resolves[id];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tthis.port.start();\n\t\tthis.port.addEventListener('message', this.handleMessage);\n\t}\n\n\t/**\n\t * @returns {ReadonlyMap<string, MgrAudioParam>}\n\t */\n\tget parameters() {\n\t\t// @ts-ignore\n\t\treturn super.parameters;\n\t}\n\n\tget processorId() {\n\t\treturn this.module.moduleId;\n\t}\n\n\tget instanceId() {\n\t\treturn this.module.instanceId;\n\t}\n\n\tasync initialize() {\n\t\t/** @type {ReturnType<ParamMgrCallToProcessor['getBuffer']>} */\n\t\tconst response = await this.call('getBuffer');\n\t\tconst { lock, paramsBuffer } = response;\n\t\tthis.$lock = lock;\n\t\tthis.$paramsBuffer = paramsBuffer;\n\t\tconst offset = 1;\n\t\tObject.entries(this.internalParamsConfig).forEach(([name, config], i) => {\n\t\t\tif (this.context.state === 'suspended') this.$paramsBuffer[i] = config.defaultValue;\n\t\t\tif (config instanceof AudioParam) {\n\t\t\t\ttry {\n\t\t\t\t\tconfig.automationRate = 'a-rate';\n\t\t\t\t// eslint-disable-next-line no-empty\n\t\t\t\t} catch {\n\t\t\t\t} finally {\n\t\t\t\t\tconfig.value = Math.max(0, config.minValue);\n\t\t\t\t\tthis.connect(config, offset + i);\n\t\t\t\t}\n\t\t\t} else if (config instanceof AudioNode) {\n\t\t\t\tthis.connect(config, offset + i);\n\t\t\t} else {\n\t\t\t\tthis.requestDispatchIParamChange(name);\n\t\t\t}\n\t\t});\n\t\tthis.connect(this.module.audioContext.destination, 0, 0);\n\t\tthis.initialized = true;\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param {ReturnType<ParamMgrCallToProcessor['getBuffer']>} buffer\n\t */\n\tsetBuffer({ lock, paramsBuffer }) {\n\t\tthis.$lock = lock;\n\t\tthis.$paramsBuffer = paramsBuffer;\n\t}\n\n\tsetParamsMapping(paramsMapping) {\n\t\treturn this.call('setParamsMapping', paramsMapping);\n\t}\n\n\tgetCompensationDelay() {\n\t\treturn this.call('getCompensationDelay');\n\t}\n\n\tgetParameterInfo(...parameterIdQuery) {\n\t\treturn this.call('getParameterInfo', ...parameterIdQuery);\n\t}\n\n\tgetParameterValues(normalized, ...parameterIdQuery) {\n\t\treturn this.call('getParameterValues', normalized, ...parameterIdQuery);\n\t}\n\n\t/**\n\t * @param {WamAutomationEvent} event\n\t */\n\tscheduleAutomation(event) {\n\t\tconst time = event.time || this.context.currentTime;\n\t\tconst { id, normalized, value } = event.data;\n\t\tconst audioParam = this.getParam(id);\n\t\tif (!audioParam) return;\n\t\tif (audioParam.info.type === 'float') {\n\t\t\tif (normalized) audioParam.linearRampToNormalizedValueAtTime(value, time);\n\t\t\telse audioParam.linearRampToValueAtTime(value, time);\n\t\t} else {\n\t\t\t// eslint-disable-next-line no-lonely-if\n\t\t\tif (normalized) audioParam.setNormalizedValueAtTime(value, time);\n\t\t\telse audioParam.setValueAtTime(value, time);\n\t\t}\n\t}\n\n\t/**\n\t * @param {WamEvent[]} events\n\t */\n\tscheduleEvents(...events) {\n\t\tevents.forEach((event) => {\n\t\t\tif (event.type === 'wam-automation') {\n\t\t\t\tthis.scheduleAutomation(event);\n\t\t\t}\n\t\t});\n\t\tthis.call('scheduleEvents', ...events);\n\t}\n\n\t/**\n\t * @param {WamEvent[]} events\n\t */\n\temitEvents(...events) {\n\t\tthis.call('emitEvents', ...events);\n\t}\n\n\tclearEvents() {\n\t\tthis.call('clearEvents');\n\t}\n\n\t/**\n\t * @param {WamEvent} event\n\t */\n\tdispatchWamEvent(event) {\n\t\tif (event.type === 'wam-automation') {\n\t\t\tthis.scheduleAutomation(event);\n\t\t} else {\n\t\t\tthis.dispatchEvent(new CustomEvent(event.type, { detail: event }));\n\t\t}\n\t}\n\n\t/**\n\t * @param {WamParameterValueMap} parameterValues\n\t */\n\tasync setParameterValues(parameterValues) {\n\t\tObject.keys(parameterValues).forEach((parameterId) => {\n\t\t\tconst parameterUpdate = parameterValues[parameterId];\n\t\t\tconst parameter = this.parameters.get(parameterId);\n\t\t\tif (!parameter) return;\n\t\t\tif (!parameterUpdate.normalized) parameter.value = parameterUpdate.value;\n\t\t\telse parameter.normalizedValue = parameterUpdate.value;\n\t\t});\n\t}\n\n\tasync getState() {\n\t\treturn this.getParamsValues();\n\t}\n\n\tasync setState(state) {\n\t\tthis.setParamsValues(state);\n\t}\n\n\tconvertTimeToFrame(time) {\n\t\treturn Math.round(time * this.context.sampleRate);\n\t}\n\n\tconvertFrameToTime(frame) {\n\t\treturn frame / this.context.sampleRate;\n\t}\n\n\t/**\n\t * @param {string} name\n\t */\n\trequestDispatchIParamChange = (name) => {\n\t\tconst config = this.internalParamsConfig[name];\n\t\tif (!('onChange' in config)) return;\n\t\tconst { automationRate, onChange } = config;\n\t\tif (typeof automationRate !== 'number' || !automationRate) return;\n\t\tconst interval = 1000 / automationRate;\n\t\tconst i = this.internalParams.indexOf(name);\n\t\tif (i === -1) return;\n\t\tif (i >= this.internalParams.length) return;\n\t\tif (typeof this.paramsUpdateCheckFnRef[i] === 'number') {\n\t\t\twindow.clearTimeout(this.paramsUpdateCheckFnRef[i]);\n\t\t}\n\n\t\tthis.paramsUpdateCheckFn[i] = () => {\n\t\t\tconst prev = this.$prevParamsBuffer[i];\n\t\t\tconst cur = this.$paramsBuffer[i];\n\t\t\tif (cur !== prev) {\n\t\t\t\tonChange(cur, prev);\n\t\t\t\tthis.$prevParamsBuffer[i] = cur;\n\t\t\t}\n\t\t\tthis.paramsUpdateCheckFnRef[i] = window.setTimeout(this.paramsUpdateCheckFn[i], interval);\n\t\t};\n\t\tthis.paramsUpdateCheckFn[i]();\n\t}\n\n\t/**\n\t * @param {string} name\n\t */\n\tgetIParamIndex(name) {\n\t\tconst i = this.internalParams.indexOf(name);\n\t\treturn i === -1 ? null : i;\n\t}\n\n\t/**\n\t * @param {string} name\n\t * @param {AudioParam | AudioNode} dest\n\t * @param {number} index\n\t */\n\tconnectIParam(name, dest, index) {\n\t\tconst offset = 1;\n\t\tconst i = this.getIParamIndex(name);\n\t\tif (i !== null) {\n\t\t\tif (dest instanceof AudioNode) {\n\t\t\t\tif (typeof index === 'number') this.connect(dest, offset + i, index);\n\t\t\t\telse this.connect(dest, offset + i);\n\t\t\t} else {\n\t\t\t\tthis.connect(dest, offset + i);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} name\n\t * @param {AudioParam | AudioNode} dest\n\t * @param {number} index\n\t */\n\tdisconnectIParam(name, dest, index) {\n\t\tconst offset = 1;\n\t\tconst i = this.getIParamIndex(name);\n\t\tif (i !== null) {\n\t\t\tif (dest instanceof AudioNode) {\n\t\t\t\tif (typeof index === 'number') this.disconnect(dest, offset + i, index);\n\t\t\t\telse this.disconnect(dest, offset + i);\n\t\t\t} else {\n\t\t\t\tthis.disconnect(dest, offset + i);\n\t\t\t}\n\t\t}\n\t}\n\n\tgetIParamValue(name) {\n\t\tconst i = this.getIParamIndex(name);\n\t\treturn i !== null ? this.$paramsBuffer[i] : null;\n\t}\n\n\tgetIParamsValues() {\n\t\t/** @type {Record<string, number>} */\n\t\tconst values = {};\n\t\tthis.internalParams.forEach((name, i) => {\n\t\t\tvalues[name] = this.$paramsBuffer[i];\n\t\t});\n\t\treturn values;\n\t}\n\n\tgetParam(name) {\n\t\treturn this.parameters.get(name) || null;\n\t}\n\n\tgetParams() {\n\t\t// @ts-ignore\n\t\treturn Object.fromEntries(this.parameters);\n\t}\n\n\tgetParamValue(name) {\n\t\tconst param = this.parameters.get(name);\n\t\tif (!param) return null;\n\t\treturn param.value;\n\t}\n\n\tsetParamValue(name, value) {\n\t\tconst param = this.parameters.get(name);\n\t\tif (!param) return;\n\t\tparam.value = value;\n\t}\n\n\tgetParamsValues() {\n\t\t/** @type {Record<string, number>} */\n\t\tconst values = {};\n\t\tthis.parameters.forEach((v, k) => {\n\t\t\tvalues[k] = v.value;\n\t\t});\n\t\treturn values;\n\t}\n\n\t/**\n\t * @param {Record<string, number>} values\n\t */\n\tsetParamsValues(values) {\n\t\tif (!values) return;\n\t\tObject.entries(values).forEach(([k, v]) => {\n\t\t\tthis.setParamValue(k, v);\n\t\t});\n\t}\n\n\tgetNormalizedParamValue(name) {\n\t\tconst param = this.parameters.get(name);\n\t\tif (!param) return null;\n\t\treturn param.normalizedValue;\n\t}\n\n\tsetNormalizedParamValue(name, value) {\n\t\tconst param = this.parameters.get(name);\n\t\tif (!param) return;\n\t\tparam.normalizedValue = value;\n\t}\n\n\tgetNormalizedParamsValues() {\n\t\tconst values = {};\n\t\tthis.parameters.forEach((v, k) => {\n\t\t\tvalues[k] = this.getNormalizedParamValue(k);\n\t\t});\n\t\treturn values;\n\t}\n\n\tsetNormalizedParamsValues(values) {\n\t\tif (!values) return;\n\t\tObject.entries(values).forEach(([k, v]) => {\n\t\t\tthis.setNormalizedParamValue(k, v);\n\t\t});\n\t}\n\n\tsetParamValueAtTime(name, value, startTime) {\n\t\tconst param = this.parameters.get(name);\n\t\tif (!param) return null;\n\t\treturn param.setValueAtTime(value, startTime);\n\t}\n\n\tsetNormalizedParamValueAtTime(name, value, startTime) {\n\t\tconst param = this.parameters.get(name);\n\t\tif (!param) return null;\n\t\treturn param.setNormalizedValueAtTime(value, startTime);\n\t}\n\n\tlinearRampToParamValueAtTime(name, value, endTime) {\n\t\tconst param = this.parameters.get(name);\n\t\tif (!param) return null;\n\t\treturn param.linearRampToValueAtTime(value, endTime);\n\t}\n\n\tlinearRampToNormalizedParamValueAtTime(name, value, endTime) {\n\t\tconst param = this.parameters.get(name);\n\t\tif (!param) return null;\n\t\treturn param.linearRampToNormalizedValueAtTime(value, endTime);\n\t}\n\n\texponentialRampToParamValueAtTime(name, value, endTime) {\n\t\tconst param = this.parameters.get(name);\n\t\tif (!param) return null;\n\t\treturn param.exponentialRampToValueAtTime(value, endTime);\n\t}\n\n\texponentialRampToNormalizedParamValueAtTime(name, value, endTime) {\n\t\tconst param = this.parameters.get(name);\n\t\tif (!param) return null;\n\t\treturn param.exponentialRampToNormalizedValueAtTime(value, endTime);\n\t}\n\n\tsetParamTargetAtTime(name, target, startTime, timeConstant) {\n\t\tconst param = this.parameters.get(name);\n\t\tif (!param) return null;\n\t\treturn param.setTargetAtTime(target, startTime, timeConstant);\n\t}\n\n\tsetNormalizedParamTargetAtTime(name, target, startTime, timeConstant) {\n\t\tconst param = this.parameters.get(name);\n\t\tif (!param) return null;\n\t\treturn param.setNormalizedTargetAtTime(target, startTime, timeConstant);\n\t}\n\n\tsetParamValueCurveAtTime(name, values, startTime, duration) {\n\t\tconst param = this.parameters.get(name);\n\t\tif (!param) return null;\n\t\treturn param.setValueCurveAtTime(values, startTime, duration);\n\t}\n\n\tsetNormalizedParamValueCurveAtTime(name, values, startTime, duration) {\n\t\tconst param = this.parameters.get(name);\n\t\tif (!param) return null;\n\t\treturn param.setNormalizedValueCurveAtTime(values, startTime, duration);\n\t}\n\n\tcancelScheduledParamValues(name, cancelTime) {\n\t\tconst param = this.parameters.get(name);\n\t\tif (!param) return null;\n\t\treturn param.cancelScheduledValues(cancelTime);\n\t}\n\n\tcancelAndHoldParamAtTime(name, cancelTime) {\n\t\tconst param = this.parameters.get(name);\n\t\tif (!param) return null;\n\t\treturn param.cancelAndHoldAtTime(cancelTime);\n\t}\n\n\t/**\n\t * @param {WamNode} to\n\t * @param {number} [output]\n\t */\n\tconnectEvents(to, output) {\n\t\tif (!to.module?.isWebAudioModule) return;\n\t\tthis.call('connectEvents', to.instanceId, output);\n\t}\n\n\t/**\n\t * @param {WamNode} [to]\n\t * @param {number} [output]\n\t */\n\tdisconnectEvents(to, output) {\n\t\tif (to && !to.module?.isWebAudioModule) return;\n\t\tthis.call('disconnectEvents', to?.instanceId, output);\n\t}\n\n\tasync destroy() {\n\t\tthis.disconnect();\n\t\tthis.paramsUpdateCheckFnRef.forEach((ref) => {\n\t\t\tif (typeof ref === 'number') window.clearTimeout(ref);\n\t\t});\n\t\tawait this.call('destroy');\n\t\tthis.port.close();\n\t}\n}\n", "import './AudioWorkletRegister.js';\nimport processor from './ParamMgrProcessor.js';\nimport wamEnvExecutable from '@webaudiomodules/sdk/src/WamEnv.js';\nimport ParamMappingConfigurator from './ParamConfigurator.js';\nimport ParamMgrNode from './ParamMgrNode.js';\n/** @typedef {import('@webaudiomodules/api').WebAudioModule} WebAudioModule */\n/** @typedef {import('./types').ParametersMappingConfiguratorOptions} ParametersMappingConfiguratorOptions */\n/** @typedef {import('./types').ParamMgrOptions} ParamMgrOptions */\n/** @typedef {import('./types').AudioWorkletRegister} AudioWorkletRegister */\n\nexport default class ParamMgrFactory {\n\t/**\n\t * @param {WebAudioModule} module\n\t * @param {ParametersMappingConfiguratorOptions} [optionsIn = {}]\n\t */\n\tstatic async create(module, optionsIn = {}) {\n\t\tconst { audioContext, moduleId: processorId, instanceId } = module;\n\t\tconst { paramsConfig, paramsMapping, internalParamsConfig } = new ParamMappingConfigurator(optionsIn);\n\t\tconst initialParamsValue = Object.entries(paramsConfig)\n\t\t\t.reduce((currentParams, [name, { defaultValue }]) => {\n\t\t\t\tcurrentParams[name] = defaultValue;\n\t\t\t\treturn currentParams;\n\t\t\t}, {});\n\t\tconst serializableParamsConfig = Object.entries(paramsConfig)\n\t\t\t.reduce((currentParams, [name, { id, label, type, defaultValue, minValue, maxValue, discreteStep, exponent, choices, units }]) => {\n\t\t\t\tcurrentParams[name] = { id, label, type, defaultValue, minValue, maxValue, discreteStep, exponent, choices, units };\n\t\t\t\treturn currentParams;\n\t\t\t}, {});\n\t\t/** @type {typeof AudioWorkletRegister} */\n\t\t// @ts-ignore\n\t\t// eslint-disable-next-line prefer-destructuring\n\t\tconst AudioWorkletRegister = window.AudioWorkletRegister;\n\t\tawait AudioWorkletRegister.register('__WebAudioModules_WamEnv', wamEnvExecutable, audioContext.audioWorklet);\n\t\tawait AudioWorkletRegister.register(processorId, processor, audioContext.audioWorklet, serializableParamsConfig);\n\t\t/** @type {ParamMgrOptions} */\n\t\tconst options = {\n\t\t\tinternalParamsConfig,\n\t\t\tparameterData: initialParamsValue,\n\t\t\tprocessorOptions: {\n\t\t\t\tparamsConfig,\n\t\t\t\tparamsMapping,\n\t\t\t\tinternalParamsMinValues: Object.values(internalParamsConfig)\n\t\t\t\t\t.map((config) => Math.max(0, config?.minValue || 0)),\n\t\t\t\tinternalParams: Object.keys(internalParamsConfig),\n\t\t\t\tinstanceId,\n\t\t\t\tprocessorId,\n\t\t\t},\n\t\t};\n\t\tconst node = new ParamMgrNode(module, options);\n\t\tawait node.initialize();\n\t\treturn node;\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
